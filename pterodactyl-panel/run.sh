#!/usr/bin/with-contenv bashio
# shellcheck disable=SC2034,SC2129,SC2016
# shellcheck shell=bash

# <ADDON_BANNER_INJECTION>

# ============================================================================
# Addon Startup Banner - Auto-generated by CI
# ============================================================================
_show_startup_banner() {
    local VERSION="0.11.0"
    local NAME="pterodactyl Panel Gameserver - BETA"
    local SLUG="pterodactyl_panel"
    local UNSUPPORTED="false"
    local MAINTAINER="FaserF"
    local REPO="$MAINTAINER/hassio-addons"

    # Extract base version and commit from dev versions (1.2.3-dev+abc123)
    local BASE_VERSION="${VERSION%%-dev*}"
    local DEV_COMMIT=""
    if [[ "$VERSION" == *"+""*" ]]; then
        DEV_COMMIT="${VERSION##*+}"
    fi

    # Header
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.blue "  üè† $NAME"
    bashio::log.blue "  üì¶ Version: $VERSION"
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    # Status indicator
    if [ "$UNSUPPORTED" = "true" ]; then
        bashio::log.error "üö® STATUS: UNSUPPORTED"
        bashio::log.error "   This addon is no longer maintained!"
    elif [[ "$VERSION" == *"-dev"* ]]; then
        bashio::log.warning "üöß STATUS: DEVELOPMENT"
        bashio::log.warning "   This is a development build!"
    elif [[ "${BASE_VERSION%%.*}" =~ ^[0-9]+$ ]] && [ "${BASE_VERSION%%.*}" -lt 1 ] 2>/dev/null; then
        bashio::log.notice "üî¨ STATUS: BETA"
        bashio::log.notice "   This addon is in beta testing."
    else
        bashio::log.green "‚úÖ STATUS: STABLE"
    fi

    # Helper for semantic version comparison (Pure Bash)
    # Returns 0 if $1 > $2, 1 otherwise
    version_gt() {
        local v1="$1"
        local v2="$2"
        if [ "$v1" = "$v2" ]; then return 1; fi

        local IFS=.
        local i ver1 ver2
        read -ra ver1 <<< "$v1"
        read -ra ver2 <<< "$v2"

        # Pad with zeros
        for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do ver1[i]=0; done
        for ((i=${#ver2[@]}; i<${#ver1[@]}; i++)); do ver2[i]=0; done

        for ((i=0; i<${#ver1[@]}; i++)); do
            # Handle non-numeric (e.g. dev versions) by treating as 0
            local n1="${ver1[i] preg_replace '[^0-9]' ''}"
            local n2="${ver2[i] preg_replace '[^0-9]' ''}"
            # Fallback for pure bash without regex substitution if needed, but lets assume simple numbers for stable check
            # Simple sanitization: remove anything not a digit
            n1=$(echo "${ver1[i]}" | tr -cd '0-9')
            n2=$(echo "${ver2[i]}" | tr -cd '0-9')

            # Empty string -> 0
            [ -z "$n1" ] && n1=0
            [ -z "$n2" ] && n2=0

            if ((10#$n1 > 10#$n2)); then return 0; fi
            if ((10#$n1 < 10#$n2)); then return 1; fi
        done
        return 1
    }

    # ========================================================================
    # Smart Update Check
    # ========================================================================
    if command -v curl &>/dev/null; then
        local UPDATE_MSG=""

        # Ensure we don't fail on pipe errors
        local LATEST_STABLE=""

        # Get latest stable version from config.yaml
        if LATEST_STABLE=$(curl -s --max-time 10 "https://raw.githubusercontent.com/$REPO/master/$SLUG/config.yaml" 2>/dev/null | grep -E "^version:" | head -1 | sed 's/version:[[:space:]]*["'"'"']\?\([^"'"'"'+]*\).*/\1/' | sed 's/-dev.*//'); then
            : # Success
        else
            LATEST_STABLE=""
        fi

        if [ -n "$LATEST_STABLE" ]; then
            # For DEV versions: Check if there are newer commits for this addon
            if [[ "$VERSION" == *"-dev"* ]]; then
                if [ -n "$DEV_COMMIT" ]; then
                    # Get latest commit for this addon from GitHub
                    local LATEST_COMMIT=""
                    if LATEST_COMMIT=$(curl -s --max-time 10 "https://api.github.com/repos/$REPO/commits?path=$SLUG&per_page=1" 2>/dev/null | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | head -c7); then
                         :
                    fi

                    if [ -n "$LATEST_COMMIT" ] && [ "$LATEST_COMMIT" != "$DEV_COMMIT" ]; then
                        UPDATE_MSG="‚¨ÜÔ∏è  DEV UPDATE: New commits available"
                        bashio::log.yellow "   Your commit: $DEV_COMMIT"
                        bashio::log.yellow "   Latest: $LATEST_COMMIT"
                    fi
                fi

                # Also check if a stable release is available
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    # Compare versions
                    if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
                        bashio::log.yellow "   Consider upgrading to the stable release"
                    fi
                fi

            # For BETA versions (< 1.0.0): Check for newer beta OR stable
            elif [[ "${BASE_VERSION%%.*}" =~ ^[0-9]+$ ]] && [ "${BASE_VERSION%%.*}" -lt 1 ] 2>/dev/null; then
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    # If stable is >= 1.0.0, it's definitely newer
                    local LATEST_MAJOR="${LATEST_STABLE%%.*}"
                    if [ "$LATEST_MAJOR" -ge 1 ] 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
                    elif version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
                    fi
                fi

            # For STABLE versions: Simple version comparison
            else
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
                    fi
                fi
            fi
        fi

        if [ -n "$UPDATE_MSG" ]; then
            bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            bashio::log.yellow "$UPDATE_MSG"
            bashio::log.yellow "   You are running: $VERSION"
            bashio::log.yellow "   Update via the Add-on Store"
            bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        fi
    fi

    # Footer with links
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.info "üìù Issues: https://github.com/$REPO/issues"
    bashio::log.info "üíñ Maintained by: $MAINTAINER"
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.info ""
}

# Show banner on startup
if type bashio::log.blue &>/dev/null 2>&1; then
    _show_startup_banner
fi

# </ADDON_BANNER_INJECTION>

# Enable strict mode
set -e
# shellcheck disable=SC1091

# Get Addon Version

SSL_CERT=/ssl/$(bashio::config 'certfile')
SSL_CERT_KEY=/ssl/$(bashio::config 'keyfile')
password_mariadb=$(bashio::config 'password')
db=panel

echo "This add-on requires the MariaDB core add-on 2.0 or newer!"

host=$(bashio::services "mysql" "host")
password=$(bashio::services "mysql" "password")
port=$(bashio::services "mysql" "port")
username=$(bashio::services "mysql" "username")

if bashio::config.true 'reset_database'; then
	if ! bashio::config.true 'reset_database_confirm'; then
		bashio::log.error "Database reset requires both 'reset_database' and 'reset_database_confirm' to be enabled!"
		bashio::log.error "This is a DESTRUCTIVE operation that will DELETE ALL DATA!"
		bashio::log.error "Set 'reset_database_confirm: true' in your configuration to proceed."
		exit 1
	fi

	bashio::log.warning "=========================================="
	bashio::log.warning "WARNING: DESTRUCTIVE DATABASE OPERATION"
	bashio::log.warning "=========================================="
	bashio::log.warning "This will DROP the entire '${db}' database!"
	bashio::log.warning "All data will be permanently lost!"
	bashio::log.warning "=========================================="

	# Create timestamped backup before dropping
	BACKUP_DIR="/share/pterodactyl/backups"
	mkdir -p "$BACKUP_DIR"
	TIMESTAMP=$(date +%Y%m%d_%H%M%S)
	BACKUP_FILE="$BACKUP_DIR/${db}_backup_${TIMESTAMP}.sql"

	bashio::log.info "Creating backup before database reset..."
	bashio::log.info "Backup location: $BACKUP_FILE"

	# Create backup using mariadb-dump with MYSQL_PWD for security
	export MYSQL_PWD="${password}"
	if mariadb-dump -h "${host}" -P "${port}" -u "${username}" --skip-ssl "${db}" >"$BACKUP_FILE" 2>/dev/null; then
		bashio::log.info "Backup created successfully: $BACKUP_FILE"
	else
		bashio::log.warning "Backup failed (database may not exist yet), continuing with reset..."
	fi
	unset MYSQL_PWD

	bashio::log.warning 'Recreating database (dropping existing if present)...'
	echo "DROP DATABASE IF EXISTS ${db};" |
		MYSQL_PWD="${password}" mariadb -h "${host}" -P "${port}" -u "${username}" || {
		bashio::log.error "Failed to drop database ${db}"
		exit 1
	}

	#Remove reset_database options
	bashio::addon.option 'reset_database'
	bashio::addon.option 'reset_database_confirm'
fi

echo "preparing database ${db}"

echo "CREATE DATABASE IF NOT EXISTS ${db};" |
	MYSQL_PWD="${password}" mariadb -h "${host}" -P "${port}" -u "${username}" || {
	bashio::log.error "Failed to create database ${db}"
	exit 1
}
echo "GRANT ALL PRIVILEGES ON ${db}.* TO 'pterodactyl' IDENTIFIED BY '${password_mariadb}' WITH GRANT OPTION;" |
	MYSQL_PWD="${password}" mariadb -h "${host}" -P "${port}" -u "${username}" || {
	bashio::log.error "Failed to grant privileges on database ${db}"
	exit 1
}

if [ "$host" = "localhost" ]; then
	host=127.0.0.1
fi

# Ensure we are in the web root
cd /var/www/html/ || {
	bashio::log.error "Could not find web root directory!"
	exit 1
}

# Fixed permissions early to ensure nginx user can read/write
bashio::log.info "Fixing permissions..."
chown -R nginx:nginx storage bootstrap/cache
chown nginx:nginx .env 2>/dev/null || true

echo "[setup] Comparing environment settings file from /share/pterodactyl/.env"
setup_user=false
if [ ! -d /share/pterodactyl/ ]; then
	mkdir -p /share/pterodactyl/
fi
if [ ! -f /share/pterodactyl/.env ]; then
	echo "No old config file found, starting first setup of pterodactyl"
	echo "[setup] Generating Application Key..."

	# Generate key manually to avoid boot errors
	APP_KEY="base64:$(openssl rand -base64 32)"
	hostname="localhost"
	echo "REDIS_HOST=$hostname" >>.env

	# Check if APP_KEY exists in .env, replace or append
	if grep -q "^APP_KEY=" .env; then
		sed -i "s|^APP_KEY=.*|APP_KEY=$APP_KEY|" .env
	else
		echo "APP_KEY=$APP_KEY" >>.env
	fi

	echo "[setup] Application Key Generated"
	cp .env /share/pterodactyl/.env
	setup_user=true
else
	echo "Config file exists, skipping first setup of pterodactyl and using existing config from /share/pterodactyl/.env"
	cp /share/pterodactyl/.env .env
fi

# Ensure APP_KEY exists (for recovery)
if ! grep -q "^APP_KEY=base64:" .env; then
	echo "[setup] Application Key missing or invalid, generating..."
	APP_KEY="base64:$(openssl rand -base64 32)"

	if grep -q "^APP_KEY=" .env; then
		sed -i "s|^APP_KEY=.*|APP_KEY=$APP_KEY|" .env
	else
		echo "APP_KEY=$APP_KEY" >>.env
	fi

	cp .env /share/pterodactyl/.env
fi

# Ensure correct permissions on .env (again, just in case)
chown nginx:nginx .env

echo ""
echo "[setup] Clearing cache/views..."

# Run cache clearing as nginx user to avoid root-owned files
su-exec nginx php artisan view:clear
su-exec nginx php artisan config:clear

echo ""
echo "[setup] Setup database credentials..."
echo "MariaDB informations: ${host} ${port}"
su-exec nginx php artisan p:environment:database --host "${host}" --port "${port}" --username "pterodactyl" --password "${password_mariadb}"

if [ "$setup_user" = "true" ]; then
	echo "[setup] Migrating/Seeding database..."
	su-exec nginx php artisan migrate --seed --no-interaction --force
fi

if [ ! -f /share/pterodactyl/config.yml ]; then
	echo "[setup] Generating default Wings configuration..."
	cat <<'EOF' >/tmp/generate_config.php
<?php
require __DIR__ . '/vendor/autoload.php';
$app = require __DIR__ . '/bootstrap/app.php';
$app->make(Illuminate\Contracts\Console\Kernel::class)->bootstrap();

use Pterodactyl\Models\Location;
use Pterodactyl\Models\Node;
use Illuminate\Support\Str;
use Ramsey\Uuid\Uuid;

$location = Location::firstOrCreate([
    'short' => 'local',
], [
    'long' => 'Local Location',
]);

$node = Node::where('name', 'Local Node')->first();
if (!$node) {
    $node = new Node();
    $node->forceFill([
        'name' => 'Local Node',
        'location_id' => $location->id,
        'fqdn' => 'local-pterodactyl-wings',
        'scheme' => 'http',
        'memory' => 0,
        'memory_overallocate' => 0,
        'disk' => 0,
        'disk_overallocate' => 0,
        'upload_size' => 100,
        'daemon_sftp' => 2022,
        'daemon_listen' => 8080,
        'uuid' => Uuid::uuid4()->toString(),
        'daemon_token' => Str::random(Node::DAEMON_TOKEN_LENGTH),
        'daemon_token_id' => Str::random(Node::DAEMON_TOKEN_ID_LENGTH),
        'public' => 1,
        'maintenance_mode' => 0,
    ]);
    $node->save();
}

$config = $app->make(\Pterodactyl\Services\Nodes\NodeConfigurationService::class)->handle($node);
echo \Symfony\Component\Yaml\Yaml::dump($config);
EOF

	# Run the script
	php /tmp/generate_config.php >/share/pterodactyl/config.yml
	rm /tmp/generate_config.php

	if [ -s /share/pterodactyl/config.yml ]; then
		echo "[setup] Wings configuration generated successfully at /share/pterodactyl/config.yml"
	else
		echo "[setup] Failed to generate Wings configuration!"
	fi
else
	echo "[setup] Wings configuration already exists at /share/pterodactyl/config.yml"
fi

if [ ! -f /share/pterodactyl/nginx_default.conf ]; then
	# Checks if SSL certificate and key exists, otherwise default to http traffic
	if bashio::config.true 'ssl'; then
		echo "[setup] SSL has been enabled. Setting nginx settings for ssl usage with ${SSL_CERT},${SSL_CERT_KEY}."
		envsubst '${SSL_CERT},${SSL_CERT_KEY}' \
			</etc/nginx/templates/https.conf >/etc/nginx/conf.d/default.conf
	else
		echo "[setup] Warning: SSL Certificate was not specified or doesn't exist, using HTTP."
		cat /etc/nginx/templates/http.conf >/etc/nginx/conf.d/default.conf
	fi
	cp /etc/nginx/conf.d/default.conf /share/pterodactyl/nginx_default.conf
else
	cp /share/pterodactyl/nginx_default.conf /etc/nginx/conf.d/default.conf
fi

if [ "$setup_user" = "true" ]; then
	echo "[setup] Creating default user..."
	su-exec nginx php artisan p:user:make --admin "1" --email "admin@example.com" --username "admin" --name-first "Default" --name-last "Admin" --password "${password_mariadb}"

	echo "For the first login use admin@example.com / admin as user and your database password to sign in."
	echo "Please ensure to change these credentials as soon as possible."
fi

echo "[start] Starting nginx and php"
# PHP-FPM is configured to run as nginx user in pool config
/usr/sbin/php-fpm83 --nodaemonize -c /etc/php83 &
php_service_pid=$!

echo "[start] Starting Pterodactyl Panel"

# Optimized permissions: Permissions were fixed early in the script

# Create log files with correct permissions
touch /var/log/nginx/pterodactyl.app-error.log
mkdir -p /var/www/html/storage/logs
touch /var/www/html/storage/logs/nginx-access.log
touch /var/www/html/storage/logs/nginx-error.log
touch /var/www/html/storage/logs/laravel-"$(date +%F)".log

chown -R nginx:nginx /var/log/nginx /var/www/html/storage/logs

# Run queue worker as nginx
su-exec nginx php /var/www/html/artisan queue:work --queue=high,standard,low --sleep=3 --tries=3 &

# Start nginx in foreground (it's configured with "daemon off")
exec /usr/sbin/nginx -g "daemon off;"
