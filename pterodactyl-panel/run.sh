#!/usr/bin/with-contenv bashio
# shellcheck disable=SC2034,SC2129,SC2016
# shellcheck shell=bash

# <ADDON_BANNER_INJECTION>

# ============================================================================
# Addon Startup Banner - Auto-generated by CI
# ============================================================================
_show_startup_banner() {
	local VERSION
	if ! VERSION=$(bashio::addon.version 2>/dev/null); then
		VERSION="unknown"
	fi
	if [ -z "$VERSION" ]; then
		VERSION="unknown"
	fi
	local NAME="pterodactyl Panel Gameserver"
	local SLUG="pterodactyl_panel"
	local UNSUPPORTED="false"
	local MAINTAINER="FaserF"
	local REPO="$MAINTAINER/hassio-addons"

	# Extract base version and commit from dev versions (1.2.3-dev+abc123)
	local BASE_VERSION="${VERSION%%-dev*}"
	local DEV_COMMIT=""
	if [[ "$VERSION" == *"+"* ]]; then
		DEV_COMMIT="${VERSION##*+}"
	fi

	# Status indicator
	if [ "$UNSUPPORTED" = "true" ]; then
		bashio::log.error "üö® STATUS: UNSUPPORTED"
		bashio::log.error "   This addon is no longer maintained!"
	elif [[ "$VERSION" == *"-dev"* ]]; then
		bashio::log.warning "üöß STATUS: DEVELOPMENT"
		bashio::log.warning "   This is a development build!"
	elif [[ "${BASE_VERSION%%.*}" =~ ^[0-9]+$ ]] && [ "${BASE_VERSION%%.*}" -lt 1 ] 2>/dev/null; then
		bashio::log.notice "üî¨ STATUS: BETA"
		bashio::log.notice "   This addon is in beta testing."
	else
		bashio::log.green "‚úÖ STATUS: STABLE"
	fi

	# Helper for semantic version comparison (Pure Bash)
	# Returns 0 if $1 > $2, 1 otherwise
	version_gt() {
		local v1="$1"
		local v2="$2"
		if [ "$v1" = "$v2" ]; then return 1; fi

		local IFS=.
		local i ver1 ver2
		read -ra ver1 <<<"$v1"
		read -ra ver2 <<<"$v2"

		# Pad with zeros
		for ((i = ${#ver1[@]}; i < ${#ver2[@]}; i++)); do ver1[i]=0; done
		for ((i = ${#ver2[@]}; i < ${#ver1[@]}; i++)); do ver2[i]=0; done

		for ((i = 0; i < ${#ver1[@]}; i++)); do
			# Handle non-numeric (e.g. dev versions) by treating as 0
			# Simple sanitization: remove anything not a digit using bash expansion
			local n1="${ver1[i]//[!0-9]/}"
			local n2="${ver2[i]//[!0-9]/}"

			# Fallback (rarely needed if using bash, but harmless to keep if desired,
			# though user suggestion implies we can rely on bash expansion)
			# We will use the bash expansion result directly.

			# Empty string -> 0
			[ -z "$n1" ] && n1=0
			[ -z "$n2" ] && n2=0

			if ((10#$n1 > 10#$n2)); then return 0; fi
			if ((10#$n1 < 10#$n2)); then return 1; fi
		done
		return 1
	}

	# ========================================================================
	# Smart Update Check
	# ========================================================================
	if command -v curl &>/dev/null; then
		local UPDATE_MSG=""

		# Ensure we don't fail on pipe errors
		local LATEST_STABLE=""

		# Get latest stable version from config.yaml
		if LATEST_STABLE=$(curl -s --max-time 10 "https://raw.githubusercontent.com/$REPO/master/$SLUG/config.yaml" 2>/dev/null | grep -E "^version:" | head -1 | sed 's/version:[[:space:]]*["'"'"']\?\([^"'"'"'+]*\).*/\1/' | sed 's/-dev.*//'); then
			: # Success
		else
			LATEST_STABLE=""
		fi

		if [ -n "$LATEST_STABLE" ]; then
			# For DEV versions: Check if there are newer commits for this addon
			if [[ "$VERSION" == *"-dev"* ]]; then
				if [ -n "$DEV_COMMIT" ]; then
					# Get latest commit for this addon from GitHub
					local LATEST_COMMIT=""
					if LATEST_COMMIT=$(curl -s --max-time 10 "https://api.github.com/repos/$REPO/commits?path=$SLUG&per_page=1" 2>/dev/null | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | head -c7); then
						:
					fi

					if [ -n "$LATEST_COMMIT" ] && [ "$LATEST_COMMIT" != "$DEV_COMMIT" ]; then
						UPDATE_MSG="‚¨ÜÔ∏è  DEV UPDATE: New commits available"
						bashio::log.yellow "   Your commit: $DEV_COMMIT"
						bashio::log.yellow "   Latest: $LATEST_COMMIT"
					fi
				fi

				# Also check if a stable release is available
				if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
					# Compare versions
					if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
						bashio::log.yellow "   Consider upgrading to the stable release"
					fi
				fi

			# For BETA versions (< 1.0.0): Check for newer beta OR stable
			elif [[ "${BASE_VERSION%%.*}" =~ ^[0-9]+$ ]] && [ "${BASE_VERSION%%.*}" -lt 1 ] 2>/dev/null; then
				if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
					# If stable is >= 1.0.0, it's definitely newer
					local LATEST_MAJOR="${LATEST_STABLE%%.*}"
					if [ "$LATEST_MAJOR" -ge 1 ] 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
					elif version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
					fi
				fi

			# For STABLE versions: Simple version comparison
			else
				if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
					if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
					fi
				fi
			fi
		fi

		if [ -n "$UPDATE_MSG" ]; then
			bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
			bashio::log.yellow "$UPDATE_MSG"
			bashio::log.yellow "   You are running: $VERSION"
			bashio::log.yellow "   Update via the Add-on Store"
			bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
		fi
	fi

	# Footer with links
	bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	bashio::log.info " Add-on: $NAME"
	bashio::log.info " üìù Issues: https://github.com/$REPO/issues"
	bashio::log.info " üíñ Maintained by: $MAINTAINER"
	bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	bashio::log.info ""
}

# Show banner on startup
if type bashio::log.blue &>/dev/null 2>&1; then
	_show_startup_banner
fi

# </ADDON_BANNER_INJECTION>

# Enable strict mode
set -e
# shellcheck disable=SC1091

# Function to ensure admin user exists and has a valid password
ensure_admin_user() {
	local db_host="$1"
	local db_port="$2"
	local db_user="$3"
	local db_name="$4"
	local db_pass="$5"
	local admin_pass="$6"

	bashio::log.info "Checking admin user status..."

	export MYSQL_PWD="$db_pass"

	# Check if admin user exists
	local user_exists
	user_exists=$(mariadb -h "$db_host" -P "$db_port" -u "$db_user" "$db_name" -N -e "SELECT COUNT(*) FROM users WHERE email = 'admin@example.com';" 2>/dev/null || echo "0")

	# Check if existing password hash is valid (BCrypt)
	local current_hash=""
	if [ "$user_exists" != "0" ]; then
		current_hash=$(mariadb -h "$db_host" -P "$db_port" -u "$db_user" "$db_name" -N -e "SELECT password FROM users WHERE email = 'admin@example.com';" 2>/dev/null)
	fi

	# Determine if we need to create or update
	local action="none"
	if [ "$user_exists" = "0" ]; then
		action="create"
		bashio::log.info "Admin user not found. Creating..."
	elif [[ ! "$current_hash" =~ ^\$2y\$ ]]; then
		action="update"
		bashio::log.warning "Admin user exists but has invalid/legacy password hash. Resetting password..."
	else
		bashio::log.info "Admin user exists with valid password hash. Skipping modification."
		return 0
	fi

	# Generate Hash safely using PHP and Environment Variable
	export ADMIN_PASS="$admin_pass"
	local hashed_pass
	hashed_pass=$(cd /var/www/html && su-exec nginx php -r 'echo password_hash(getenv("ADMIN_PASS"), PASSWORD_BCRYPT);' 2>/dev/null || echo "")

	if [ -z "$hashed_pass" ]; then
		bashio::log.error "Failed to generate password hash! Admin user cannot be configured."
		return 1
	fi

	local external_id
	external_id=$(openssl rand -hex 16)
	local uuid
	uuid=$(cd /var/www/html && su-exec nginx php -r "require '/var/www/html/vendor/autoload.php'; echo Ramsey\Uuid\Uuid::uuid4()->toString();" 2>/dev/null || echo "")
	if [ -z "$uuid" ]; then
		uuid=$(openssl rand -hex 16 | sed 's/\(........\)\(....\)\(....\)\(....\)\(............\)/\1-\2-\3-\4-\5/')
	fi

	if [ "$action" = "create" ]; then
		if mariadb -h "$db_host" -P "$db_port" -u "$db_user" "$db_name" <<EOF 2>&1; then
INSERT INTO users (external_id, root_admin, language, use_totp, totp_secret, email, username, name_first, name_last, password, uuid, updated_at, created_at)
VALUES ('${external_id}', 1, 'en', 0, NULL, 'admin@example.com', 'admin', 'Default', 'Admin', '${hashed_pass}', '${uuid}', NOW(), NOW());
EOF
			bashio::log.info "‚úì Admin user created successfully."
			echo "For the first login use admin@example.com / admin as user and your database password to sign in."
		else
			bashio::log.error "Failed to create admin user."
		fi
	elif [ "$action" = "update" ]; then
		if mariadb -h "$db_host" -P "$db_port" -u "$db_user" "$db_name" -e "UPDATE users SET password = '${hashed_pass}' WHERE email = 'admin@example.com';" 2>/dev/null; then
			bashio::log.info "‚úì Admin user password reset successfully."
		else
			bashio::log.error "Failed to reset admin password."
		fi
	fi

	unset MYSQL_PWD
	unset ADMIN_PASS
}

# Get Addon Version

SSL_CERT="/ssl/$(bashio::config 'certfile')"
SSL_CERT_KEY="/ssl/$(bashio::config 'keyfile')"
export SSL_CERT SSL_CERT_KEY
password_mariadb=$(bashio::config 'password')
db=panel

echo "This add-on requires the MariaDB core add-on 2.0 or newer!"

host=$(bashio::services "mysql" "host")
password=$(bashio::services "mysql" "password")
port=$(bashio::services "mysql" "port")
username=$(bashio::services "mysql" "username")

if bashio::config.true 'reset_database'; then
	if ! bashio::config.true 'reset_database_confirm'; then
		bashio::log.error "Database reset requires both 'reset_database' and 'reset_database_confirm' to be enabled!"
		bashio::log.error "This is a DESTRUCTIVE operation that will DELETE ALL DATA!"
		bashio::log.error "Set 'reset_database_confirm: true' in your configuration to proceed."
		exit 1
	fi

	bashio::log.warning "=========================================="
	bashio::log.warning "WARNING: DESTRUCTIVE DATABASE OPERATION"
	bashio::log.warning "=========================================="
	bashio::log.warning "This will DROP the entire '${db}' database!"
	bashio::log.warning "All data will be permanently lost!"
	bashio::log.warning "=========================================="

	# Create timestamped backup before dropping
	BACKUP_DIR="/share/pterodactyl/backups"
	mkdir -p "$BACKUP_DIR"
	TIMESTAMP=$(date +%Y%m%d_%H%M%S)
	BACKUP_FILE="$BACKUP_DIR/${db}_backup_${TIMESTAMP}.sql"

	bashio::log.info "Creating backup before database reset..."
	bashio::log.info "Backup location: $BACKUP_FILE"

	# Create backup using mariadb-dump with MYSQL_PWD for security
	export MYSQL_PWD="${password}"
	if mariadb-dump -h "${host}" -P "${port}" -u "${username}" --skip-ssl "${db}" >"$BACKUP_FILE" 2>/dev/null; then
		bashio::log.info "Backup created successfully: $BACKUP_FILE"
	else
		bashio::log.warning "Backup failed (database may not exist yet), continuing with reset..."
	fi
	unset MYSQL_PWD

	bashio::log.warning 'Recreating database (dropping existing if present)...'
	echo "DROP DATABASE IF EXISTS ${db};" |
		MYSQL_PWD="${password}" mariadb -h "${host}" -P "${port}" -u "${username}" || {
		bashio::log.error "Failed to drop database ${db}"
		exit 1
	}

	#Remove reset_database options
	bashio::addon.option 'reset_database'
	bashio::addon.option 'reset_database_confirm'
fi

echo "preparing database ${db}"

echo "CREATE DATABASE IF NOT EXISTS ${db};" |
	MYSQL_PWD="${password}" mariadb -h "${host}" -P "${port}" -u "${username}" || {
	bashio::log.error "Failed to create database ${db}"
	exit 1
}
if [ -z "$password_mariadb" ]; then
	if [ -f .env ]; then
		password_mariadb=$(grep "^DB_PASSWORD=" .env | cut -d'=' -f2)
	fi
	if [ -z "$password_mariadb" ]; then
		password_mariadb=$(openssl rand -base64 12)
		bashio::log.warning "No database password set in configuration! Generating random password: ${password_mariadb}"
		bashio::log.warning "Please save this password if you need direct database access."
	fi
fi

echo "GRANT ALL PRIVILEGES ON ${db}.* TO 'pterodactyl' IDENTIFIED BY '${password_mariadb}' WITH GRANT OPTION;" |
	MYSQL_PWD="${password}" mariadb -h "${host}" -P "${port}" -u "${username}" || {
	bashio::log.error "Failed to grant privileges on database ${db}"
	exit 1
}

if [ "$host" = "localhost" ]; then
	host=127.0.0.1
fi

# Ensure we are in the web root
cd /var/www/html/ || {
	bashio::log.error "Could not find web root directory!"
	exit 1
}

# Fixed permissions early to ensure nginx user can read/write
bashio::log.info "Fixing permissions..."
chown -R nginx:nginx storage bootstrap/cache
chown nginx:nginx .env 2>/dev/null || true

echo "[setup] Comparing environment settings file from /share/pterodactyl/.env"
setup_user=false
if [ ! -d /share/pterodactyl/ ]; then
	mkdir -p /share/pterodactyl/
fi
if [ ! -f /share/pterodactyl/.env ]; then
	echo "No old config file found, starting first setup of pterodactyl"
	echo "[setup] Generating Application Key..."

	# Generate key manually to avoid boot errors
	APP_KEY="base64:$(openssl rand -base64 32)"
	hostname="localhost"
	echo "REDIS_HOST=$hostname" >>.env

	# Check if APP_KEY exists in .env, replace or append
	if grep -q "^APP_KEY=" .env; then
		sed -i "s|^APP_KEY=.*|APP_KEY=$APP_KEY|" .env
	else
		echo "APP_KEY=$APP_KEY" >>.env
	fi

	echo "[setup] Application Key Generated"
	cp .env /share/pterodactyl/.env
	setup_user=true
else
	echo "Config file exists, skipping first setup of pterodactyl and using existing config from /share/pterodactyl/.env"
	cp /share/pterodactyl/.env .env
fi

# Ensure APP_KEY exists (for recovery)
if ! grep -q "^APP_KEY=base64:" .env; then
	echo "[setup] Application Key missing or invalid, generating..."
	APP_KEY="base64:$(openssl rand -base64 32)"

	if grep -q "^APP_KEY=" .env; then
		sed -i "s|^APP_KEY=.*|APP_KEY=$APP_KEY|" .env
	else
		echo "APP_KEY=$APP_KEY" >>.env
	fi

	cp .env /share/pterodactyl/.env
fi

# Ensure correct permissions on .env (again, just in case)
chown nginx:nginx .env

echo "[setup] Setting APP_URL..."
# Use configured app_url if available, otherwise fall back to Ingress URL
if bashio::config.has_value 'app_url' && [ -n "$(bashio::config 'app_url')" ]; then
	APP_URL=$(bashio::config 'app_url')
	bashio::log.info "Using configured APP_URL: $APP_URL"
elif bashio::var.has_value "$(bashio::addon.ingress_url)"; then
	APP_URL="$(bashio::addon.ingress_url)"
	bashio::log.info "No app_url configured, using Ingress URL for APP_URL: $APP_URL"
else
	APP_URL="http://pterodactyl.local"
	bashio::log.warning "No APP_URL configured and Ingress not available, using default: $APP_URL"
fi

if grep -q "^APP_URL=" .env; then
	sed -i "s|^APP_URL=.*|APP_URL=$APP_URL|" .env
else
	echo "APP_URL=$APP_URL" >>.env
fi

# Force HTTPS if APP_URL uses HTTPS (for Cloudflare Tunnel or reverse proxies)
if [[ "$APP_URL" == https://* ]]; then
	bashio::log.info "APP_URL uses HTTPS, ensuring secure session cookies..."
	# Set session secure flag if not already set
	if ! grep -q "^SESSION_SECURE_COOKIE=" .env; then
		echo "SESSION_SECURE_COOKIE=true" >>.env
	fi
fi

# Configure trusted proxies for reverse proxy/ingress setup
# Pterodactyl needs to trust the proxy headers when behind Home Assistant Ingress
if ! grep -q "^TRUSTED_PROXIES=" .env; then
	echo "TRUSTED_PROXIES=*" >>.env
	bashio::log.info "Configured TRUSTED_PROXIES=* for reverse proxy support"
fi

# Ensure session domain is not set (let Laravel use default)
# This helps with cookie issues behind reverse proxies
if grep -q "^SESSION_DOMAIN=" .env; then
	sed -i "s|^SESSION_DOMAIN=.*|#SESSION_DOMAIN=|" .env
	bashio::log.info "Removed SESSION_DOMAIN to allow Laravel to handle it automatically"
fi

# Ensure session driver is set to file (default, but make sure it's set)
if ! grep -q "^SESSION_DRIVER=" .env; then
	echo "SESSION_DRIVER=file" >>.env
	bashio::log.info "Set SESSION_DRIVER=file"
fi

sed -i "s|^APP_ENV=.*|APP_ENV=production|" .env

# Map log_level to APP_DEBUG
log_level=$(bashio::config 'log_level')
case "${log_level}" in
trace | debug) app_debug="true" ;;
info | notice | warning | warn | error | fatal) app_debug="false" ;;
*) app_debug="false" ;;
esac
if [ "$app_debug" = "true" ]; then
	bashio::log.warning "APP_DEBUG enabled (log_level: $log_level)"
fi

if ! grep -q "^APP_DEBUG=" .env; then
	echo "APP_DEBUG=$app_debug" >>.env
else
	sed -i "s|^APP_DEBUG=.*|APP_DEBUG=$app_debug|" .env
fi

echo ""
echo "[setup] Clearing cache/views..."

# Run cache clearing as nginx user to avoid root-owned files
su-exec nginx php artisan view:clear
su-exec nginx php artisan config:clear

echo ""
echo "[setup] Setup database credentials..."
echo "MariaDB informations: ${host} ${port}"
su-exec nginx php artisan p:environment:database --host "${host}" --port "${port}" --username "pterodactyl" --password "${password_mariadb}" --no-interaction

# Disable SSL for database connection (MariaDB core addon doesn't support SSL)
# Remove any SSL-related database configuration
if grep -q "^DB_SSL_CA=" .env; then
	sed -i "s|^DB_SSL_CA=.*|#DB_SSL_CA=|" .env
	bashio::log.info "Disabled DB_SSL_CA"
fi
if grep -q "^DB_SSL_CERT=" .env; then
	sed -i "s|^DB_SSL_CERT=.*|#DB_SSL_CERT=|" .env
	bashio::log.info "Disabled DB_SSL_CERT"
fi
if grep -q "^DB_SSL_KEY=" .env; then
	sed -i "s|^DB_SSL_KEY=.*|#DB_SSL_KEY=|" .env
	bashio::log.info "Disabled DB_SSL_KEY"
fi
# Ensure SSL is explicitly disabled
if ! grep -q "^DB_SSL=" .env; then
	echo "DB_SSL=false" >>.env
	bashio::log.info "Set DB_SSL=false to disable SSL for database connection"
else
	sed -i "s|^DB_SSL=.*|DB_SSL=false|" .env
	bashio::log.info "Updated DB_SSL=false to disable SSL for database connection"
fi

# Check if database tables exist by querying the users table
echo "[setup] Checking if database tables exist..."
export MYSQL_PWD="${password_mariadb}"
TABLE_COUNT=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '${db}' AND table_name = 'users';" 2>/dev/null | tail -n 1 || echo "0")
unset MYSQL_PWD

# Clear config cache again after database SSL settings were updated
su-exec nginx php artisan config:clear

# The schema loader uses mysql command directly and requires SSL
# We need to disable schema loading by removing or renaming the schema file
# This is safe because migrations will create the tables anyway
SCHEMA_FILE="database/schema/mysql-schema.sql"
if [ -f "$SCHEMA_FILE" ]; then
	bashio::log.info "Temporarily disabling schema loader to avoid SSL issues..."
	mv "$SCHEMA_FILE" "${SCHEMA_FILE}.disabled" 2>/dev/null || true
	bashio::log.info "Schema file disabled. Migrations will create tables from scratch."
fi

# Pre-mark problematic migration if daemonSecret doesn't exist
# This must be done BEFORE running migrations to prevent the error
# But we need to wait for migrations table to be created first
# So we'll check and mark it after the first migration creates the table
export MYSQL_PWD="${password_mariadb}"
MIGRATIONS_TABLE_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '${db}' AND table_name = 'migrations';" 2>/dev/null | tail -n 1 || echo "0")

if [ "$MIGRATIONS_TABLE_EXISTS" != "0" ]; then
	# Check if daemonSecret column exists in nodes table
	DAEMON_SECRET_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = '${db}' AND table_name = 'nodes' AND column_name = 'daemonSecret';" 2>/dev/null | tail -n 1 || echo "0")
	MIGRATION_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM migrations WHERE migration = '2020_04_10_141024_store_node_tokens_as_encrypted_value';" 2>/dev/null | tail -n 1 || echo "0")

	# If daemonSecret doesn't exist and migration isn't marked, pre-mark it
	if [ "$DAEMON_SECRET_EXISTS" = "0" ] && [ "$MIGRATION_EXISTS" = "0" ]; then
		bashio::log.info "Pre-marking migration '2020_04_10_141024_store_node_tokens_as_encrypted_value' as completed (daemonSecret column doesn't exist)..."
		MAX_BATCH=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COALESCE(MAX(batch), 0) FROM migrations;" 2>/dev/null | tail -n 1 || echo "1")
		NEW_BATCH=$((MAX_BATCH + 1))
		mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "INSERT IGNORE INTO migrations (migration, batch) VALUES ('2020_04_10_141024_store_node_tokens_as_encrypted_value', ${NEW_BATCH});" 2>/dev/null || true
		bashio::log.info "Migration pre-marked as completed."
	fi
fi
unset MYSQL_PWD

if [ "$TABLE_COUNT" = "0" ] || [ -z "$TABLE_COUNT" ]; then
	bashio::log.warning "Database tables not found. Running migrations..."
	echo "[setup] Migrating/Seeding database..."

	# Temporarily rename the problematic migration file to prevent it from running
	PROBLEMATIC_MIGRATION="database/migrations/2020_04_10_141024_store_node_tokens_as_encrypted_value.php"
	if [ -f "$PROBLEMATIC_MIGRATION" ]; then
		bashio::log.info "Temporarily disabling problematic migration file..."
		mv "$PROBLEMATIC_MIGRATION" "${PROBLEMATIC_MIGRATION}.disabled" 2>/dev/null || true
	fi

	# Run migrations - schema loader is disabled, so SSL won't be an issue
	# Use --force to continue even if some migrations fail
	su-exec nginx php artisan migrate --seed --no-interaction --force || {
		bashio::log.warning "Some migrations may have failed. Checking if critical tables exist..."
		# Check if users table exists (critical for panel to work)
		export MYSQL_PWD="${password_mariadb}"
		USERS_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '${db}' AND table_name = 'users';" 2>/dev/null | tail -n 1 || echo "0")
		unset MYSQL_PWD
		if [ "$USERS_EXISTS" = "0" ]; then
			bashio::log.error "Critical users table not found after migration. Database setup may be incomplete."
			exit 1
		fi
		bashio::log.warning "Migration completed with warnings, but critical tables exist. Continuing..."
	}

	# Re-enable the problematic migration file and mark it as completed
	if [ -f "${PROBLEMATIC_MIGRATION}.disabled" ]; then
		bashio::log.info "Re-enabling problematic migration file and marking it as completed..."
		mv "${PROBLEMATIC_MIGRATION}.disabled" "$PROBLEMATIC_MIGRATION" 2>/dev/null || true

		# Mark the migration as completed in the database
		export MYSQL_PWD="${password_mariadb}"
		MIGRATIONS_TABLE_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '${db}' AND table_name = 'migrations';" 2>/dev/null | tail -n 1 || echo "0")
		if [ "$MIGRATIONS_TABLE_EXISTS" != "0" ]; then
			MIGRATION_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM migrations WHERE migration = '2020_04_10_141024_store_node_tokens_as_encrypted_value';" 2>/dev/null | tail -n 1 || echo "0")
			if [ "$MIGRATION_EXISTS" = "0" ]; then
				MAX_BATCH=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COALESCE(MAX(batch), 0) FROM migrations;" 2>/dev/null | tail -n 1 || echo "1")
				NEW_BATCH=$((MAX_BATCH + 1))
				mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "INSERT IGNORE INTO migrations (migration, batch) VALUES ('2020_04_10_141024_store_node_tokens_as_encrypted_value', ${NEW_BATCH});" 2>/dev/null || true
				bashio::log.info "Problematic migration marked as completed in database."
			fi
		fi
		unset MYSQL_PWD
	fi

	# Function to ensure admin user exists and has a valid password
	if [ "$setup_user" != "true" ]; then
		ensure_admin_user "${host}" "${port}" "pterodactyl" "${db}" "${password_mariadb}" "${password_mariadb}"
	fi
elif [ "$setup_user" = "true" ]; then
	echo "[setup] Migrating/Seeding database..."

	# Temporarily rename the problematic migration file to prevent it from running
	PROBLEMATIC_MIGRATION="database/migrations/2020_04_10_141024_store_node_tokens_as_encrypted_value.php"
	if [ -f "$PROBLEMATIC_MIGRATION" ]; then
		bashio::log.info "Temporarily disabling problematic migration file..."
		mv "$PROBLEMATIC_MIGRATION" "${PROBLEMATIC_MIGRATION}.disabled" 2>/dev/null || true
	fi

	# Run migrations with explicit SSL disabled
	su-exec nginx php artisan migrate --seed --no-interaction --force || {
		bashio::log.warning "Migration completed with warnings. Continuing..."
	}

	# Re-enable the problematic migration file and mark it as completed
	if [ -f "${PROBLEMATIC_MIGRATION}.disabled" ]; then
		bashio::log.info "Re-enabling problematic migration file and marking it as completed..."
		mv "${PROBLEMATIC_MIGRATION}.disabled" "$PROBLEMATIC_MIGRATION" 2>/dev/null || true

		# Mark the migration as completed in the database
		export MYSQL_PWD="${password_mariadb}"
		MIGRATIONS_TABLE_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '${db}' AND table_name = 'migrations';" 2>/dev/null | tail -n 1 || echo "0")
		if [ "$MIGRATIONS_TABLE_EXISTS" != "0" ]; then
			MIGRATION_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM migrations WHERE migration = '2020_04_10_141024_store_node_tokens_as_encrypted_value';" 2>/dev/null | tail -n 1 || echo "0")
			if [ "$MIGRATION_EXISTS" = "0" ]; then
				MAX_BATCH=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COALESCE(MAX(batch), 0) FROM migrations;" 2>/dev/null | tail -n 1 || echo "1")
				NEW_BATCH=$((MAX_BATCH + 1))
				mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "INSERT IGNORE INTO migrations (migration, batch) VALUES ('2020_04_10_141024_store_node_tokens_as_encrypted_value', ${NEW_BATCH});" 2>/dev/null || true
				bashio::log.info "Problematic migration marked as completed in database."
			fi
		fi
		unset MYSQL_PWD
	fi
else
	bashio::log.info "Database tables exist. Running migrations to ensure schema is up to date..."
	# Run migrations without seed to ensure schema is up to date
	# Continue even if some migrations fail (they may have already run)
	su-exec nginx php artisan migrate --no-interaction --force || {
		bashio::log.warning "Some migrations may have failed, but continuing..."
	}

	# Ensure admin user exists (check/create even if not first run)
	ensure_admin_user "${host}" "${port}" "pterodactyl" "${db}" "${password_mariadb}" "${password_mariadb}"

fi

# Check if default location and node should be created
# This runs after migrations to ensure tables exist
# Note: This is a "nice to have" feature - errors are logged but don't stop the add-on from starting
bashio::log.info "Checking if default location and node need to be created..."

# Wait a moment for database to be fully ready after migrations
sleep 3

# Initialize variables
LOCATIONS_TABLE_EXISTS="0"
NODES_TABLE_EXISTS="0"
LOCATION_COUNT="0"
NODE_COUNT="0"

# Check if locations and nodes tables exist first
export MYSQL_PWD="${password_mariadb}"

# Test database connection first
if ! mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT 1;" >/dev/null 2>&1; then
	bashio::log.warning "‚ö† Cannot connect to database. Skipping automatic location/node creation."
	unset MYSQL_PWD
else
	LOCATIONS_TABLE_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '${db}' AND table_name = 'locations';" 2>/dev/null | tail -n 1 || echo "0")
	NODES_TABLE_EXISTS=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = '${db}' AND table_name = 'nodes';" 2>/dev/null | tail -n 1 || echo "0")

	bashio::log.info "Table existence check: locations=${LOCATIONS_TABLE_EXISTS}, nodes=${NODES_TABLE_EXISTS}"

	if [ "$LOCATIONS_TABLE_EXISTS" = "0" ] || [ "$NODES_TABLE_EXISTS" = "0" ]; then
		bashio::log.warning "‚ö† Locations or Nodes tables don't exist yet. Skipping automatic creation."
		bashio::log.warning "This is normal on first start - tables will be created by migrations."
		unset MYSQL_PWD
	else
		# Tables exist, check counts
		LOCATION_COUNT=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM locations;" 2>/dev/null | tail -n 1 || echo "0")
		NODE_COUNT=$(mariadb -h "${host}" -P "${port}" -u "pterodactyl" "${db}" -e "SELECT COUNT(*) FROM nodes;" 2>/dev/null | tail -n 1 || echo "0")
		unset MYSQL_PWD

		bashio::log.info "Current database state: Locations=${LOCATION_COUNT}, Nodes=${NODE_COUNT}"
	fi
fi

# Create default location and node if they don't exist
# This is optional - errors are logged but don't stop the add-on
if [ "$LOCATIONS_TABLE_EXISTS" != "0" ] && [ "$NODES_TABLE_EXISTS" != "0" ] && { [ "$LOCATION_COUNT" = "0" ] || [ "$NODE_COUNT" = "0" ]; }; then
	bashio::log.info "Location or Node count is 0, attempting to create default location and node for Wings (optional feature)..."

	# Extract FQDN and scheme from APP_URL
	APP_URL_HOST="${APP_URL#http://}"
	APP_URL_HOST="${APP_URL_HOST#https://}"
	APP_URL_HOST="${APP_URL_HOST%%/*}"

	# Determine scheme and port
	if [[ "$APP_URL" == https://* ]]; then
		SCHEME="https"
		# Extract port from APP_URL if present, otherwise use default 443
		if [[ "$APP_URL_HOST" == *:* ]]; then
			WINGS_PORT="${APP_URL_HOST##*:}"
			WINGS_FQDN="${APP_URL_HOST%:*}"
		else
			WINGS_PORT="443"
			WINGS_FQDN="$APP_URL_HOST"
		fi
	else
		SCHEME="http"
		# Extract port from APP_URL if present, otherwise use default 80
		if [[ "$APP_URL_HOST" == *:* ]]; then
			WINGS_PORT="${APP_URL_HOST##*:}"
			WINGS_FQDN="${APP_URL_HOST%:*}"
		else
			WINGS_PORT="80"
			WINGS_FQDN="$APP_URL_HOST"
		fi
	fi

	# Default Wings daemon port (can be changed in Wings config)
	DAEMON_LISTEN="8080"
	DAEMON_SFTP="2022"

	# File directories - use /share/pterodactyl for persistent storage
	DATA_DIR="/share/pterodactyl"

	bashio::log.info "Configuring default location and node:"
	bashio::log.info "  FQDN: ${WINGS_FQDN}"
	bashio::log.info "  Scheme: ${SCHEME}"
	bashio::log.info "  Port: ${WINGS_PORT}"
	bashio::log.info "  Daemon Listen: ${DAEMON_LISTEN}"
	bashio::log.info "  Data Directory: ${DATA_DIR}"

	cat <<EOF >/tmp/setup_location_node.php
<?php
require '/var/www/html/vendor/autoload.php';
\$app = require '/var/www/html/bootstrap/app.php';
\$app->make(Illuminate\Contracts\Console\Kernel::class)->bootstrap();

use Pterodactyl\Models\Location;
use Pterodactyl\Models\Node;
use Illuminate\Support\Str;
use Ramsey\Uuid\Uuid;

try {
    // Create or get default location
    \$location = Location::firstOrCreate([
        'short' => 'default',
    ], [
        'long' => 'Default Location',
    ]);

    echo "Location ID: " . \$location->id . "\n";

    // Check if default node exists
    \$node = Node::where('name', 'Default Node')->first();
    if (!\$node) {
        \$node = new Node();
        \$node->forceFill([
            'name' => 'Default Node',
            'location_id' => \$location->id,
            'fqdn' => '${WINGS_FQDN}',
            'scheme' => '${SCHEME}',
            'memory' => 1024,
            'memory_overallocate' => 0,
            'disk' => 10240,
            'disk_overallocate' => 0,
            'upload_size' => 100,
            'daemon_sftp' => ${DAEMON_SFTP},
            'daemon_listen' => ${DAEMON_LISTEN},
            'uuid' => Uuid::uuid4()->toString(),
            'daemon_token' => Str::random(Node::DAEMON_TOKEN_LENGTH),
            'daemon_token_id' => Str::random(Node::DAEMON_TOKEN_ID_LENGTH),
            'public' => 1,
            'maintenance_mode' => 0,
        ]);
        \$node->save();
        echo "Node created with UUID: " . \$node->uuid . "\n";
        echo "Node FQDN: " . \$node->fqdn . "\n";
        echo "Node Scheme: " . \$node->scheme . "\n";
    } else {
        // Update existing node with correct FQDN and scheme
        \$node->fqdn = '${WINGS_FQDN}';
        \$node->scheme = '${SCHEME}';
        \$node->daemon_listen = ${DAEMON_LISTEN};
        \$node->daemon_sftp = ${DAEMON_SFTP};
        \$node->save();
        echo "Node updated with UUID: " . \$node->uuid . "\n";
        echo "Node FQDN: " . \$node->fqdn . "\n";
        echo "Node Scheme: " . \$node->scheme . "\n";
    }

    // Generate Wings configuration
    \$config = \$app->make(\Pterodactyl\Services\Nodes\NodeConfigurationService::class)->handle(\$node);

    // Update file paths in config to use persistent storage
    \$config['system']['data'] = '${DATA_DIR}/servers';
    \$config['system']['backup_directory'] = '${DATA_DIR}/backups';
    \$config['system']['log_directory'] = '${DATA_DIR}/logs';

    echo \Symfony\Component\Yaml\Yaml::dump(\$config);
} catch (\Exception \$e) {
    echo "ERROR: " . \$e->getMessage() . "\n";
    exit(1);
}
EOF

	# Run the script - errors are logged but don't stop the add-on
	if su-exec nginx php /tmp/setup_location_node.php >/share/pterodactyl/config.yml 2>&1; then
		if [ -s /share/pterodactyl/config.yml ] && ! grep -q "^ERROR:" /share/pterodactyl/config.yml 2>/dev/null; then
			bashio::log.info "‚úì Default location and node created successfully"
			bashio::log.info "‚úì Wings configuration generated at /share/pterodactyl/config.yml"
		else
			bashio::log.warning "‚ö† Failed to generate Wings configuration (this is optional)"
			if [ -s /share/pterodactyl/config.yml ]; then
				bashio::log.warning "Error details:"
				grep "^ERROR:" /share/pterodactyl/config.yml 2>/dev/null || cat /share/pterodactyl/config.yml | head -5
			fi
		fi
	else
		bashio::log.warning "‚ö† Failed to create default location and node (this is optional)"
		bashio::log.warning "You can create them manually in the Panel web interface"
		if [ -s /share/pterodactyl/config.yml ]; then
			bashio::log.warning "Error output:"
			cat /share/pterodactyl/config.yml | head -10
		fi
	fi
	rm -f /tmp/setup_location_node.php
elif [ ! -f /share/pterodactyl/config.yml ]; then
	# If location/node exist but config.yml doesn't, regenerate it
	bashio::log.info "Regenerating Wings configuration from existing node..."
	cat <<'EOF' >/tmp/generate_config.php
<?php
try {
    require '/var/www/html/vendor/autoload.php';
    $app = require '/var/www/html/bootstrap/app.php';
    $app->make(Illuminate\Contracts\Console\Kernel::class)->bootstrap();

    use Pterodactyl\Models\Node;

    $node = Node::first();
    if ($node) {
        $config = $app->make(\Pterodactyl\Services\Nodes\NodeConfigurationService::class)->handle($node);

        // Update file paths in config to use persistent storage
        $config['system']['data'] = '/share/pterodactyl/servers';
        $config['system']['backup_directory'] = '/share/pterodactyl/backups';
        $config['system']['log_directory'] = '/share/pterodactyl/logs';

        echo \Symfony\Component\Yaml\Yaml::dump($config);
    } else {
        echo "# No nodes found\n";
    }
} catch (\Exception $e) {
    echo "ERROR: " . $e->getMessage() . "\n";
    exit(1);
}
EOF

	if su-exec nginx php /tmp/generate_config.php >/share/pterodactyl/config.yml 2>&1; then
		if [ -s /share/pterodactyl/config.yml ] && ! grep -q "^ERROR:" /share/pterodactyl/config.yml 2>/dev/null; then
			bashio::log.info "‚úì Wings configuration regenerated successfully"
		else
			bashio::log.warning "‚ö† Failed to regenerate Wings configuration (this is optional)"
		fi
	else
		bashio::log.warning "‚ö† Failed to regenerate Wings configuration (this is optional)"
	fi
	rm -f /tmp/generate_config.php
else
	bashio::log.info "Location and Node already exist (Locations=${LOCATION_COUNT}, Nodes=${NODE_COUNT})"
	bashio::log.info "Wings configuration already exists at /share/pterodactyl/config.yml"
fi

# Create required directories for Wings
mkdir -p /share/pterodactyl/servers /share/pterodactyl/backups /share/pterodactyl/logs
chown -R nginx:nginx /share/pterodactyl 2>/dev/null || true
bashio::log.info "Created Wings data directories:"
bashio::log.info "  Servers: /share/pterodactyl/servers"
bashio::log.info "  Backups: /share/pterodactyl/backups"
bashio::log.info "  Logs: /share/pterodactyl/logs"

# Checks if SSL certificate and key exists, otherwise default to http traffic
if bashio::config.true 'ssl'; then
	if [ ! -f "${SSL_CERT}" ] || [ ! -f "${SSL_CERT_KEY}" ]; then
		bashio::log.error "SSL disabled: Certificate or key file not found!"
		bashio::log.error "Make sure ${SSL_CERT} and ${SSL_CERT_KEY} exist."
		bashio::log.error "Reverting to HTTP."
		cat /etc/nginx/templates/http.conf >/etc/nginx/conf.d/default.conf
	else
		echo "[setup] SSL has been enabled. Setting nginx settings for ssl usage with ${SSL_CERT} and ${SSL_CERT_KEY}."
		envsubst '${SSL_CERT} ${SSL_CERT_KEY}' \
			</etc/nginx/templates/https.conf >/etc/nginx/conf.d/default.conf
	fi
else
	echo "[setup] SSL is disabled, using HTTP."
	cat /etc/nginx/templates/http.conf >/etc/nginx/conf.d/default.conf
fi

# Warning if APP_URL doesn't match SSL setting
if bashio::config.true 'ssl' && [[ "${APP_URL}" == http://* ]]; then
	bashio::log.warning "SSL is enabled, but APP_URL starts with http://. Consider changing it to https://."
elif ! bashio::config.true 'ssl' && [[ "${APP_URL}" == https://* ]]; then
	bashio::log.warning "SSL is disabled, but APP_URL starts with https://. Consider changing it to http://."
fi

# Ensure admin user exists (replaces duplicate block)
ensure_admin_user "${host}" "${port}" "pterodactyl" "${db}" "${password_mariadb}" "${password_mariadb}"

echo "[start] Starting nginx and php"
# PHP-FPM is configured to run as nginx user in pool config
/usr/sbin/php-fpm83 --nodaemonize -c /etc/php83 &
php_service_pid=$!

echo "[start] Starting Pterodactyl Panel"

# Optimized permissions: Permissions were fixed early in the script

# Create log files with correct permissions
touch /var/log/nginx/pterodactyl.app-error.log
mkdir -p /var/www/html/storage/logs
touch /var/www/html/storage/logs/nginx-access.log
touch /var/www/html/storage/logs/nginx-error.log
touch /var/www/html/storage/logs/laravel-"$(date +%F)".log

chown -R nginx:nginx /var/log/nginx /var/www/html/storage/logs

# Run queue worker as nginx
su-exec nginx php /var/www/html/artisan queue:work --queue=high,standard,low --sleep=3 --tries=3 &

# Start nginx in foreground (it's configured with "daemon off")
exec /usr/sbin/nginx -g "daemon off;"
