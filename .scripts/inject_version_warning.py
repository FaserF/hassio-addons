#!/usr/bin/env python3
"""
Inject addon startup banner into Dockerfiles and run scripts during CI build.

This script creates a comprehensive startup banner with:
- Version and status information
- Smart update check (works for stable, beta, dev)
- Link to GitHub issues
- Maintainer information
- Appropriate warnings for dev/beta/unsupported

Usage:
    python3 inject_version_warning.py <addon_path>
"""

import os
import re
import sys

import yaml

# Configuration
GITHUB_REPO = "FaserF/hassio-addons"
MAINTAINER = "FaserF"


def get_addon_info(addon_path: str) -> dict:
    """Read addon info from config.yaml."""
    config_path = os.path.join(addon_path, "config.yaml")
    if not os.path.exists(config_path):
        config_path = os.path.join(addon_path, "config.json")

    info = {
        "version": "unknown",
        "name": os.path.basename(addon_path.rstrip("/\\")),
        "slug": os.path.basename(addon_path.rstrip("/\\")),
    }

    if not os.path.exists(config_path):
        return info

    try:
        with open(config_path, "r", encoding="utf-8") as f:
            if config_path.endswith(".yaml"):
                config = yaml.safe_load(f)
            else:
                import json

                config = json.load(f)

            info["version"] = str(config.get("version", "unknown"))
            info["name"] = config.get("name", info["name"])
            info["slug"] = config.get("slug", info["slug"])
    except Exception as e:
        print(f"‚ö†Ô∏è Could not read config: {e}")

    return info


def is_unsupported(addon_path: str) -> bool:
    """Check if addon is in .unsupported directory."""
    normalized = addon_path.replace("\\", "/")
    return ".unsupported/" in normalized or normalized.startswith(".unsupported")


def generate_startup_banner_code(addon_info: dict, unsupported: bool) -> str:
    """Generate the bash startup banner code to inject into run.sh."""
    version = addon_info["version"]
    name = addon_info["name"]
    slug = addon_info["slug"]

    # Escape for bash
    name_escaped = name.replace('"', '\\"')

    code = f"""
# ============================================================================
# Addon Startup Banner - Auto-generated by CI
# ============================================================================
_show_startup_banner() {{
    local VERSION="{version}"
    local NAME="{name_escaped}"
    local SLUG="{slug}"
    local UNSUPPORTED="{"true" if unsupported else "false"}"
    local REPO="{GITHUB_REPO}"
    local MAINTAINER="{MAINTAINER}"

    # Extract base version and commit from dev versions (1.2.3-dev+abc123)
    local BASE_VERSION="${{VERSION%%-dev*}}"
    local DEV_COMMIT=""
    if [[ "$VERSION" == *"+""*" ]]; then
        DEV_COMMIT="${{VERSION##*+}}"
    fi

    # Header
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.blue "  üè† $NAME"
    bashio::log.blue "  üì¶ Version: $VERSION"
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    # Status indicator
    if [ "$UNSUPPORTED" = "true" ]; then
        bashio::log.error "üö® STATUS: UNSUPPORTED"
        bashio::log.error "   This addon is no longer maintained!"
    elif [[ "$VERSION" == *"-dev"* ]]; then
        bashio::log.warning "üöß STATUS: DEVELOPMENT"
        bashio::log.warning "   This is a development build!"
    elif [[ "${{BASE_VERSION%%.*}}" =~ ^[0-9]+$ ]] && [ "${{BASE_VERSION%%.*}}" -lt 1 ] 2>/dev/null; then
        bashio::log.notice "üî¨ STATUS: BETA"
        bashio::log.notice "   This addon is in beta testing."
    else
        bashio::log.green "‚úÖ STATUS: STABLE"
    fi

    # ========================================================================
    # Smart Update Check
    # ========================================================================
    if command -v curl &>/dev/null; then
        local UPDATE_MSG=""

        # Get latest stable version from config.yaml
        local LATEST_STABLE
        LATEST_STABLE=$(curl -s "https://raw.githubusercontent.com/$REPO/master/$SLUG/config.yaml" 2>/dev/null | grep -E "^version:" | head -1 | sed 's/version:[[:space:]]*[\"'"'"']\\?\\([^\"'"'"'+]*\\).*/\\1/' | sed 's/-dev.*//')

        if [ -n "$LATEST_STABLE" ]; then
            # For DEV versions: Check if there are newer commits for this addon
            if [[ "$VERSION" == *"-dev"* ]]; then
                if [ -n "$DEV_COMMIT" ]; then
                    # Get latest commit for this addon from GitHub
                    local LATEST_COMMIT
                    LATEST_COMMIT=$(curl -s "https://api.github.com/repos/$REPO/commits?path=$SLUG&per_page=1" 2>/dev/null | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | head -c7)

                    if [ -n "$LATEST_COMMIT" ] && [ "$LATEST_COMMIT" != "$DEV_COMMIT" ]; then
                        UPDATE_MSG="‚¨ÜÔ∏è  DEV UPDATE: New commits available"
                        bashio::log.yellow "   Your commit: $DEV_COMMIT"
                        bashio::log.yellow "   Latest: $LATEST_COMMIT"
                    fi
                fi

                # Also check if a stable release is available
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    # Compare versions
                    if [[ "$LATEST_STABLE" > "$BASE_VERSION" ]] 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
                        bashio::log.yellow "   Consider upgrading to the stable release"
                    fi
                fi

            # For BETA versions (< 1.0.0): Check for newer beta OR stable
            elif [[ "${{BASE_VERSION%%.*}}" =~ ^[0-9]+$ ]] && [ "${{BASE_VERSION%%.*}}" -lt 1 ] 2>/dev/null; then
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    # If stable is >= 1.0.0, it's definitely newer
                    local LATEST_MAJOR="${{LATEST_STABLE%%.*}}"
                    if [ "$LATEST_MAJOR" -ge 1 ] 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
                    elif [[ "$LATEST_STABLE" > "$BASE_VERSION" ]] 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
                    fi
                fi

            # For STABLE versions: Simple version comparison
            else
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    if [[ "$LATEST_STABLE" > "$BASE_VERSION" ]] 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
                    fi
                fi
            fi
        fi

        if [ -n "$UPDATE_MSG" ]; then
            bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            bashio::log.yellow "$UPDATE_MSG"
            bashio::log.yellow "   You are running: $VERSION"
            bashio::log.yellow "   Update via the Add-on Store"
            bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        fi
    fi

    # Footer with links
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.info "üìù Issues: https://github.com/$REPO/issues"
    bashio::log.info "üíñ Maintained by: $MAINTAINER"
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.info ""
}}

# Show banner on startup
if type bashio::log.blue &>/dev/null 2>&1; then
    _show_startup_banner
fi
"""
    return code


def inject_dockerfile_env(addon_path: str, addon_info: dict, unsupported: bool) -> bool:
    """Inject ENV variables into Dockerfile."""
    dockerfile_path = os.path.join(addon_path, "Dockerfile")
    if not os.path.exists(dockerfile_path):
        print(f"‚ö†Ô∏è No Dockerfile found in {addon_path}")
        return False

    with open(dockerfile_path, "r", encoding="utf-8") as f:
        content = f.read()

    version = addon_info["version"]
    name = addon_info["name"]
    slug = addon_info["slug"]

    env_block = f"""
# Addon metadata (injected by CI)
ENV ADDON_VERSION="{version}"
ENV ADDON_NAME="{name}"
ENV ADDON_SLUG="{slug}"
ENV ADDON_UNSUPPORTED="{str(unsupported).lower()}"
"""

    # Remove existing injection if present
    content = re.sub(
        r'\n# Addon metadata \(injected by CI\)\nENV ADDON_VERSION="[^"]*"\nENV ADDON_NAME="[^"]*"\nENV ADDON_SLUG="[^"]*"\nENV ADDON_UNSUPPORTED="[^"]*"\n',
        "\n",
        content,
    )

    # Find place to insert (after FROM/ARG but before RUN)
    lines = content.split("\n")
    insert_idx = len(lines)

    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith(
            ("RUN ", "COPY ", "ADD ", "WORKDIR ")
        ) and not stripped.startswith("# "):
            insert_idx = i
            break

    lines.insert(insert_idx, env_block)
    content = "\n".join(lines)

    with open(dockerfile_path, "w", encoding="utf-8") as f:
        f.write(content)

    print(f"‚úÖ Injected ENV vars into Dockerfile")
    return True


def find_run_script(addon_path: str) -> str | None:
    """Find the main run script for the addon."""
    candidates = [
        os.path.join(addon_path, "run.sh"),
        os.path.join(addon_path, "rootfs", "run.sh"),
        os.path.join(addon_path, "rootfs", "etc", "services.d", "addon", "run"),
    ]

    for candidate in candidates:
        if os.path.exists(candidate):
            return candidate

    # Search for any run file in services.d
    services_dir = os.path.join(addon_path, "rootfs", "etc", "services.d")
    if os.path.isdir(services_dir):
        for service in os.listdir(services_dir):
            run_path = os.path.join(services_dir, service, "run")
            if os.path.exists(run_path):
                return run_path

    return None


def inject_run_script(addon_path: str, addon_info: dict, unsupported: bool) -> bool:
    """Inject startup banner into the main run script."""
    run_script = find_run_script(addon_path)

    if not run_script:
        print("‚ÑπÔ∏è No run script found, skipping banner injection")
        return False

    with open(run_script, "r", encoding="utf-8") as f:
        content = f.read()

    # Check if already injected
    if "_show_startup_banner" in content:
        print("‚ÑπÔ∏è Startup banner already present, updating...")
        # Remove old injection
        content = re.sub(
            r"\n# =+\n# Addon Startup Banner.*?_show_startup_banner\nfi\n",
            "\n",
            content,
            flags=re.DOTALL,
        )

    # Generate banner code
    banner_code = generate_startup_banner_code(addon_info, unsupported)

    # Insert after shebang
    lines = content.split("\n")
    insert_idx = 0

    for i, line in enumerate(lines):
        if line.startswith("#!"):
            insert_idx = i + 1
            break

    # Also skip any initial comment blocks
    while insert_idx < len(lines) and lines[insert_idx].strip().startswith("#"):
        insert_idx += 1

    lines.insert(insert_idx, banner_code)
    content = "\n".join(lines)

    with open(run_script, "w", encoding="utf-8") as f:
        f.write(content)

    print(f"‚úÖ Injected startup banner into {run_script}")
    return True


def main():
    if len(sys.argv) < 2:
        print("Usage: inject_version_warning.py <addon_path>")
        sys.exit(1)

    addon_path = sys.argv[1]

    if not os.path.isdir(addon_path):
        print(f"‚ùå Addon path not found: {addon_path}")
        sys.exit(1)

    print(f"üîß Processing addon: {addon_path}")

    # Get addon info
    addon_info = get_addon_info(addon_path)
    unsupported = is_unsupported(addon_path)

    print(f"   Name: {addon_info['name']}")
    print(f"   Version: {addon_info['version']}")
    print(f"   Unsupported: {unsupported}")

    # Inject into Dockerfile (ENV vars)
    inject_dockerfile_env(addon_path, addon_info, unsupported)

    # Inject into run script (banner code)
    inject_run_script(addon_path, addon_info, unsupported)

    print("‚úÖ Injection complete!")


if __name__ == "__main__":
    main()
