#!/usr/bin/env python3
"""
Inject addon startup banner into Dockerfiles and run scripts during CI build.

This script creates a comprehensive startup banner with:
- Version and status information
- Smart update check (works for stable, beta, dev)
- Link to GitHub issues
- Maintainer information
- Appropriate warnings for dev/beta/unsupported

Usage:
    python3 inject_version_warning.py <addon_path>
"""

import os
import re
import sys

import yaml

# Configuration
GITHUB_REPO = "FaserF/hassio-addons"
MAINTAINER = "FaserF"


def get_addon_info(addon_path: str) -> dict:
    """Read addon info from config.yaml."""
    config_path = os.path.join(addon_path, "config.yaml")
    if not os.path.exists(config_path):
        config_path = os.path.join(addon_path, "config.json")

    info = {
        "version": "unknown",
        "name": os.path.basename(addon_path.rstrip("/\\")),
        "slug": os.path.basename(addon_path.rstrip("/\\")),
    }

    if not os.path.exists(config_path):
        return info

    try:
        with open(config_path, "r", encoding="utf-8") as f:
            if config_path.endswith(".yaml"):
                config = yaml.safe_load(f)
            else:
                import json

                config = json.load(f)

            info["version"] = str(config.get("version", "unknown"))
            info["name"] = config.get("name", info["name"])
            info["slug"] = config.get("slug", info["slug"])
    except (yaml.YAMLError, OSError, ValueError) as e:
        print(f"‚ö†Ô∏è Could not read config: {e}")

    return info


def is_unsupported(addon_path: str) -> bool:
    """Check if addon is in .unsupported directory."""
    normalized = addon_path.replace("\\", "/")
    return ".unsupported/" in normalized or normalized.startswith(".unsupported")


def generate_startup_banner_code(addon_info: dict, unsupported: bool) -> str:
    """Generate the bash startup banner code to inject into run.sh."""
    version = addon_info["version"]
    name = addon_info["name"]
    slug = addon_info["slug"]

    # Escape for bash (escape \, ", `, $)
    name_escaped = (
        name.replace("\\", "\\\\")
        .replace('"', '\\"')
        .replace("`", "\\`")
        .replace("$", "\\$")
    )

    code = f"""
# ============================================================================
# Addon Startup Banner - Auto-generated by CI
# ============================================================================
_show_startup_banner() {{
    local VERSION
    if ! VERSION=$(bashio::addon.version 2>/dev/null); then
        VERSION="unknown"
    fi
    if [ -z "$VERSION" ]; then
        VERSION="unknown"
    fi
    local NAME="{name_escaped}"
    local SLUG="{slug}"
    local UNSUPPORTED="{"true" if unsupported else "false"}"
    local MAINTAINER="{MAINTAINER}"
    local REPO="$MAINTAINER/hassio-addons"

    # Extract base version and commit from dev versions (1.2.3-dev+abc123)
    local BASE_VERSION="${{VERSION%%-dev*}}"
    local DEV_COMMIT=""
    if [[ "$VERSION" == *"+"* ]]; then
        DEV_COMMIT="${{VERSION##*+}}"
    fi

    # Status indicator
    if [ "$UNSUPPORTED" = "true" ]; then
        bashio::log.error "üö® STATUS: UNSUPPORTED"
        bashio::log.error "   This addon is no longer maintained!"
    elif [[ "$VERSION" == *"-dev"* ]]; then
        bashio::log.warning "üöß STATUS: DEVELOPMENT"
        bashio::log.warning "   This is a development build!"
    elif [[ "${{BASE_VERSION%%.*}}" =~ ^[0-9]+$ ]] && [ "${{BASE_VERSION%%.*}}" -lt 1 ] 2>/dev/null; then
        bashio::log.notice "üî¨ STATUS: BETA"
        bashio::log.notice "   This addon is in beta testing."
    else
        bashio::log.green "‚úÖ STATUS: STABLE"
    fi

    # Helper for semantic version comparison (Pure Bash)
    # Returns 0 if $1 > $2, 1 otherwise
    version_gt() {{
        local v1="$1"
        local v2="$2"
        if [ "$v1" = "$v2" ]; then return 1; fi

        local IFS=.
        local i ver1 ver2
        read -ra ver1 <<< "$v1"
        read -ra ver2 <<< "$v2"

        # Pad with zeros
        for ((i=${{#ver1[@]}}; i<${{#ver2[@]}}; i++)); do ver1[i]=0; done
        for ((i=${{#ver2[@]}}; i<${{#ver1[@]}}; i++)); do ver2[i]=0; done

        for ((i=0; i<${{#ver1[@]}}; i++)); do
            # Handle non-numeric (e.g. dev versions) by treating as 0
            # Simple sanitization: remove anything not a digit using bash expansion
            local n1="${{ver1[i]//[!0-9]/}}"
            local n2="${{ver2[i]//[!0-9]/}}"

            # Fallback (rarely needed if using bash, but harmless to keep if desired,
            # though user suggestion implies we can rely on bash expansion)
            # We will use the bash expansion result directly.

            # Empty string -> 0
            [ -z "$n1" ] && n1=0
            [ -z "$n2" ] && n2=0

            if ((10#$n1 > 10#$n2)); then return 0; fi
            if ((10#$n1 < 10#$n2)); then return 1; fi
        done
        return 1
    }}

    # ========================================================================
    # Smart Update Check
    # ========================================================================
    if command -v curl &>/dev/null; then
        local UPDATE_MSG=""

        # Ensure we don't fail on pipe errors
        local LATEST_STABLE=""

        # Get latest stable version from config.yaml
        if LATEST_STABLE=$(curl -s --max-time 10 "https://raw.githubusercontent.com/$REPO/master/$SLUG/config.yaml" 2>/dev/null | grep -E "^version:" | head -1 | sed 's/version:[[:space:]]*[\"'"'"']\\?\\([^\"'"'"'+]*\\).*/\\1/' | sed 's/-dev.*//'); then
            : # Success
        else
            LATEST_STABLE=""
        fi

        if [ -n "$LATEST_STABLE" ]; then
            # For DEV versions: Check if there are newer commits for this addon
            if [[ "$VERSION" == *"-dev"* ]]; then
                if [ -n "$DEV_COMMIT" ]; then
                    # Get latest commit for this addon from GitHub
                    local LATEST_COMMIT=""
                    if LATEST_COMMIT=$(curl -s --max-time 10 "https://api.github.com/repos/$REPO/commits?path=$SLUG&per_page=1" 2>/dev/null | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | head -c7); then
                         :
                    fi

                    if [ -n "$LATEST_COMMIT" ] && [ "$LATEST_COMMIT" != "$DEV_COMMIT" ]; then
                        UPDATE_MSG="‚¨ÜÔ∏è  DEV UPDATE: New commits available"
                        bashio::log.yellow "   Your commit: $DEV_COMMIT"
                        bashio::log.yellow "   Latest: $LATEST_COMMIT"
                    fi
                fi

                # Also check if a stable release is available
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    # Compare versions
                    if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
                        bashio::log.yellow "   Consider upgrading to the stable release"
                    fi
                fi

            # For BETA versions (< 1.0.0): Check for newer beta OR stable
            elif [[ "${{BASE_VERSION%%.*}}" =~ ^[0-9]+$ ]] && [ "${{BASE_VERSION%%.*}}" -lt 1 ] 2>/dev/null; then
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    # If stable is >= 1.0.0, it's definitely newer
                    local LATEST_MAJOR="${{LATEST_STABLE%%.*}}"
                    if [ "$LATEST_MAJOR" -ge 1 ] 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
                    elif version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
                    fi
                fi

            # For STABLE versions: Simple version comparison
            else
                if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
                    if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
                        UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
                    fi
                fi
            fi
        fi

        if [ -n "$UPDATE_MSG" ]; then
            bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            bashio::log.yellow "$UPDATE_MSG"
            bashio::log.yellow "   You are running: $VERSION"
            bashio::log.yellow "   Update via the Add-on Store"
            bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        fi
    fi

    # Footer with links
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.info "üìù Issues: https://github.com/$REPO/issues"
    bashio::log.info "üíñ Maintained by: $MAINTAINER"
    bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    bashio::log.info ""
}}

# Show banner on startup
if type bashio::log.blue &>/dev/null 2>&1; then
    _show_startup_banner
fi
"""
    return code


def inject_dockerfile_env(addon_path: str, addon_info: dict, unsupported: bool) -> bool:
    """Inject ENV variables into Dockerfile."""
    dockerfile_path = os.path.join(addon_path, "Dockerfile")
    if not os.path.exists(dockerfile_path):
        print(f"‚ö†Ô∏è No Dockerfile found in {addon_path}")
        return False

    with open(dockerfile_path, "r", encoding="utf-8") as f:
        content = f.read()

    version = addon_info["version"]
    name = addon_info["name"]
    slug = addon_info["slug"]

    def escape_env(val):
        return val.replace("\\", "\\\\").replace('"', '\\"').replace("\n", "\\n")

    env_block = f"""
# Addon metadata (injected by CI)
ENV ADDON_VERSION="{escape_env(version)}"
ENV ADDON_NAME="{escape_env(name)}"
ENV ADDON_SLUG="{escape_env(slug)}"
ENV ADDON_UNSUPPORTED="{str(unsupported).lower()}"
"""

    # Remove existing injection if present
    content = re.sub(
        r'\n# Addon metadata \(injected by CI\)\nENV ADDON_VERSION="[^"]*"\nENV ADDON_NAME="[^"]*"\nENV ADDON_SLUG="[^"]*"\nENV ADDON_UNSUPPORTED="[^"]*"\n',
        "\n",
        content,
    )

    # Find place to insert (after FROM/ARG but before RUN)
    lines = content.split("\n")
    insert_idx = len(lines)

    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith(
            ("RUN ", "COPY ", "ADD ", "WORKDIR ")
        ) and not stripped.startswith("# "):
            insert_idx = i
            break

    lines.insert(insert_idx, env_block)
    content = "\n".join(lines)

    with open(dockerfile_path, "w", encoding="utf-8") as f:
        f.write(content)

    print("‚úÖ Injected ENV vars into Dockerfile")
    return True


def find_run_script(addon_path: str) -> str | None:
    """Find the main run script for the addon."""
    candidates = [
        os.path.join(addon_path, "run.sh"),
        os.path.join(addon_path, "rootfs", "run.sh"),
        os.path.join(addon_path, "rootfs", "etc", "services.d", "addon", "run"),
    ]

    for candidate in candidates:
        if os.path.exists(candidate):
            return candidate

    # Search for any run file in services.d
    services_dir = os.path.join(addon_path, "rootfs", "etc", "services.d")
    if os.path.isdir(services_dir):
        for service in os.listdir(services_dir):
            run_path = os.path.join(services_dir, service, "run")
            if os.path.exists(run_path):
                return run_path

    return None


def inject_run_script(addon_path: str, addon_info: dict, unsupported: bool) -> bool:
    """Inject startup banner into the main run script."""
    run_script = find_run_script(addon_path)

    if not run_script:
        print("[INFO] No run script found, skipping banner injection")
        return False

    with open(run_script, "r", encoding="utf-8") as f:
        content = f.read()

    # Valid markers
    START_MARKER = "# <ADDON_BANNER_INJECTION>"
    END_MARKER = "# </ADDON_BANNER_INJECTION>"

    # Check if already injected (Markers)
    if START_MARKER in content and END_MARKER in content:
        print("[INFO] Startup banner (markers) found, updating...")
        # Remove old injection with markers
        pattern = re.escape(START_MARKER) + r".*?" + re.escape(END_MARKER) + r"\n?"
        content = re.sub(pattern, "", content, flags=re.DOTALL)

    # Legacy cleanup (Regex)
    elif "_show_startup_banner" in content:
        print("[INFO] Legacy startup banner found, upgrading to markers...")
        content = re.sub(
            r"\n# =+\n# Addon Startup Banner.*?_show_startup_banner\nfi\n",
            "\n",
            content,
            flags=re.DOTALL,
        )

    # Generate banner code with markers
    banner_body = generate_startup_banner_code(addon_info, unsupported)
    banner_code = f"\n{START_MARKER}\n{banner_body}\n{END_MARKER}\n"

    # Insert after shebang
    lines = content.split("\n")
    insert_idx = 0

    for i, line in enumerate(lines):
        if line.startswith("#!"):
            insert_idx = i + 1
            break

    # Also skip any initial comment blocks
    while insert_idx < len(lines) and lines[insert_idx].strip().startswith("#"):
        insert_idx += 1

    lines.insert(insert_idx, banner_code)
    content = "\n".join(lines)

    with open(run_script, "w", encoding="utf-8", newline="\n") as f:
        f.write(content.replace("\r\n", "\n"))

    print(f"‚úÖ Injected startup banner into {run_script}")
    return True


def main():
    if len(sys.argv) < 2:
        print("Usage: inject_version_warning.py <addon_path>")
        sys.exit(1)

    addon_path = sys.argv[1]

    if not os.path.isdir(addon_path):
        print(f"‚ùå Addon path not found: {addon_path}")
        sys.exit(1)

    print(f"üîß Processing addon: {addon_path}")

    # Get addon info
    addon_info = get_addon_info(addon_path)
    unsupported = is_unsupported(addon_path)

    print(f"   Name: {addon_info['name']}")
    print(f"   Version: {addon_info['version']}")
    print(f"   Unsupported: {unsupported}")

    # Inject into Dockerfile (ENV vars)
    success_env = inject_dockerfile_env(addon_path, addon_info, unsupported)

    # Inject into run script (banner code)
    success_run = inject_run_script(addon_path, addon_info, unsupported)

    if not success_env and not success_run:
        print("‚ö†Ô∏è No changes made (no Dockerfile or run script found).")
        # If neither succeeded, we might want to flag it?
        # User requested considering exit status.
        sys.exit(1)

    print("‚úÖ Injection complete!")


if __name__ == "__main__":
    main()
