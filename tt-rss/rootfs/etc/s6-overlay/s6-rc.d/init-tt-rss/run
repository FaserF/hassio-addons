#!/usr/bin/env bashio
# shellcheck shell=bash

bashio::log.info "Configuring Tiny Tiny RSS..."

# Retrieve DB Password
bashio::log.info "Debugging: Checking /data/options.json"
ls -l /data/options.json || bashio::log.warning "/data/options.json not found!"
cat /data/options.json || bashio::log.warning "Could not read /data/options.json"

# Retrieve or Generate DB Password
if ! bashio::fs.file_exists "/data/ttrss_db_password"; then
    (
        umask 077
        openssl rand -base64 32 > /data/ttrss_db_password
    )
fi
if ! TTRSS_DB_PASSWORD=$(cat /data/ttrss_db_password) || [ -z "$TTRSS_DB_PASSWORD" ]; then
    bashio::exit.nok "Failed to read database password from /data/ttrss_db_password"
fi

# Generate config.php
bashio::log.info "Generating config.php..."
# Default Ingress Entry to / to avoid API call errors
SELF_URL_PATH="/"

# If self_url is set in options, use it, else default to ingress path
if ! CONFIG_SELF_URL=$(bashio::config 'self_url'); then
    bashio::log.warning "Failed to fetch configuration via bashio::config. Ignoring."
fi

# Log Level Configuration
if ! LOG_LEVEL=$(bashio::config 'log_level') || [ -z "$LOG_LEVEL" ]; then
    bashio::log.warning "Failed to fetch log_level configuration. Using default: info"
    LOG_LEVEL="info"
fi
bashio::log.level "${LOG_LEVEL}"
bashio::log.info "Log level set to ${LOG_LEVEL}"

# Map Bashio log level to PHP-FPM and Nginx levels
case "${LOG_LEVEL}" in
    trace|debug)
        PHP_LOG_LEVEL="debug"
        NGINX_LOG_LEVEL="debug"
        PHP_ERROR_REPORTING="E_ALL"
        ;;
    info|notice)
        PHP_LOG_LEVEL="notice"
        NGINX_LOG_LEVEL="info"
        PHP_ERROR_REPORTING="E_ERROR | E_WARNING | E_PARSE"
        ;;
    warning)
        PHP_LOG_LEVEL="warning"
        NGINX_LOG_LEVEL="warn"
        PHP_ERROR_REPORTING="E_ERROR | E_WARNING"
        ;;
    error|fatal)
        PHP_LOG_LEVEL="error"
        NGINX_LOG_LEVEL="error"
        PHP_ERROR_REPORTING="E_ERROR"
        ;;
    *)
        PHP_LOG_LEVEL="notice"
        NGINX_LOG_LEVEL="info"
        PHP_ERROR_REPORTING="E_ERROR | E_WARNING | E_PARSE"
        ;;
esac

# We will handle the fallback dynamically in PHP now
# But we pass the bashio config value if it exists

# Ensure PHP-FPM listens on 127.0.0.1:9000
bashio::log.info "Configuring PHP-FPM..."
cat > /etc/php84/php-fpm.d/www.conf <<EOF
[global]
error_log = /proc/self/fd/2
log_level = ${PHP_LOG_LEVEL}

[www]
user = nginx
group = nginx
listen = 127.0.0.1:9000
pm = dynamic
pm.max_children = 10
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3
clear_env = no
catch_workers_output = yes
decorate_workers_output = no
EOF

cat > /var/www/tt-rss/config.php <<EOF
<?php
    // Dynamically determine SELF_URL_PATH
    // Priority:
    // 1. Config option 'self_url' (if set and not empty)
    // 2. HTTP_X_INGRESS_PATH (if accessing via Ingress)
    // 3. Root '/' (fallback)

    \$configured_url = '${CONFIG_SELF_URL}';

    if (!empty(\$configured_url)) {
        \$self_url = \$configured_url;
    } elseif (isset(\$_SERVER['HTTP_X_INGRESS_PATH'])) {
        \$self_url = \$_SERVER['HTTP_X_INGRESS_PATH'] . '/';
    } else {
        \$self_url = '/';
    }

    putenv('TTRSS_DB_TYPE=pgsql');
    putenv('TTRSS_DB_HOST=127.0.0.1');
    putenv('TTRSS_DB_USER=ttrss');
    putenv('TTRSS_DB_NAME=ttrss');
    putenv('TTRSS_DB_PASS=${TTRSS_DB_PASSWORD}');
    putenv('TTRSS_DB_PORT=5432');
    putenv('TTRSS_SELF_URL_PATH=' . \$self_url);
    putenv('TTRSS_PHP_EXECUTABLE=/usr/bin/php');
    putenv('TTRSS_SINGLE_USER_MODE=true');
    putenv('TTRSS_SIMPLE_UPDATE_MODE=true');

    error_log("DEBUG: Auto-detected SELF_URL_PATH: " . \$self_url);

    error_reporting(${PHP_ERROR_REPORTING});

    define('DB_TYPE', 'pgsql');
    define('DB_HOST', '127.0.0.1');
    define('DB_USER', 'ttrss');
    define('DB_NAME', 'ttrss');
    define('DB_PASS', '${TTRSS_DB_PASSWORD}');
    define('DB_PORT', '5432');
    define('SELF_URL_PATH', \$self_url);
    define('PHP_EXECUTABLE', '/usr/bin/php');
    define('SINGLE_USER_MODE', true);
    define('SIMPLE_UPDATE_MODE', true);
    define('auth_internal', true);
    define('PLUGINS', 'auth_internal, note');
    define('LOG_DESTINATION', '');
    define('CHECK_FOR_UPDATES', false);
    define('ENABLE_GZIP_OUTPUT', false);
    define('SESSION_COOKIE_LIFETIME', 86400*30);
    // Handle reverse proxy
    if (isset(\$_SERVER['HTTP_X_FORWARDED_PROTO']) && \$_SERVER['HTTP_X_FORWARDED_PROTO'] == 'https') {
        \$_SERVER['HTTPS'] = 'on';
    }
EOF

# Permission fix
chown -R nginx:nginx /var/www/tt-rss
chmod -R 755 /var/www/tt-rss

# Generate Nginx Config
bashio::log.info "Generating Nginx configuration..."
SSL_ENABLED=$(bashio::config 'ssl' || echo 'false')
CERTFILE=$(bashio::config 'certfile' || echo 'fullchain.pem')
KEYFILE=$(bashio::config 'keyfile' || echo 'privkey.pem')

# Prepare main Nginx config (HTTP 8280)
cat > /etc/nginx/servers/ingress.conf <<EOF
server {
    listen 8280 default_server;
    root /var/www/tt-rss;
    index index.php index.html index.htm;
    server_name _;
    client_max_body_size 64m;
    error_log stderr ${NGINX_LOG_LEVEL};

    location / {
        try_files \$uri \$uri/ /index.php;
    }

    location ~ \.php$ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
        # Pass Ingress headers to PHP
        fastcgi_param HTTP_X_INGRESS_PATH \$http_x_ingress_path;
        fastcgi_param HTTP_X_FORWARDED_PROTO \$http_x_forwarded_proto;
    }
}
EOF

# Add SSL Server Block (HTTPS 8281) if enabled
if [ "$SSL_ENABLED" = "true" ]; then
    bashio::log.info "SSL is enabled. Configuring HTTPS on port 8281..."
    if bashio::fs.file_exists "/ssl/${CERTFILE}" && bashio::fs.file_exists "/ssl/${KEYFILE}"; then
        cat >> /etc/nginx/servers/ingress.conf <<EOF

server {
    listen 8281 ssl;
    root /var/www/tt-rss;
    index index.php index.html index.htm;
    server_name _;
    client_max_body_size 64m;
    error_log stderr ${NGINX_LOG_LEVEL};

    ssl_certificate /ssl/${CERTFILE};
    ssl_certificate_key /ssl/${KEYFILE};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    location / {
        try_files \$uri \$uri/ /index.php;
    }

    location ~ \.php$ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
    }
}
EOF
    else
        bashio::log.error "SSL enabled but certificates not found at /ssl/${CERTFILE} or /ssl/${KEYFILE}. HTTPS will not be available."
    fi
fi
