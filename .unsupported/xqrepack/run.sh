#!/usr/bin/with-contenv bashio
# shellcheck shell=bash

# <ADDON_BANNER_INJECTION>

# ============================================================================
# Addon Startup Banner - Auto-generated by CI
# ============================================================================
_show_startup_banner() {
	local VERSION="2.0.0"
	local NAME="xqrepack (Unsupported)"
	local SLUG="xqrepack"
	local UNSUPPORTED="true"
	local REPO="FaserF/hassio-addons"
	local MAINTAINER="FaserF"

	# Extract base version and commit from dev versions (1.2.3-dev+abc123)
	local BASE_VERSION="${VERSION%%-dev*}"
	local DEV_COMMIT=""
	if [[ "$VERSION" == *"+""*" ]]; then
		DEV_COMMIT="${VERSION##*+}"
	fi

	# Header
	bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	bashio::log.blue "  üè† $NAME"
	bashio::log.blue "  üì¶ Version: $VERSION"
	bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

	# Status indicator
	if [ "$UNSUPPORTED" = "true" ]; then
		bashio::log.error "üö® STATUS: UNSUPPORTED"
		bashio::log.error "   This addon is no longer maintained!"
	elif [[ "$VERSION" == *"-dev"* ]]; then
		bashio::log.warning "üöß STATUS: DEVELOPMENT"
		bashio::log.warning "   This is a development build!"
	elif [[ "${BASE_VERSION%%.*}" =~ ^[0-9]+$ ]] && [ "${BASE_VERSION%%.*}" -lt 1 ] 2>/dev/null; then
		bashio::log.notice "üî¨ STATUS: BETA"
		bashio::log.notice "   This addon is in beta testing."
	else
		bashio::log.green "‚úÖ STATUS: STABLE"
	fi

	# Helper for semantic version comparison
	version_gt() { test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"; }

	# ========================================================================
	# Smart Update Check
	# ========================================================================
	if command -v curl &>/dev/null; then
		local UPDATE_MSG=""

		# Get latest stable version from config.yaml
		local LATEST_STABLE
		LATEST_STABLE=$(curl -s --max-time 10 "https://raw.githubusercontent.com/$REPO/master/$SLUG/config.yaml" 2>/dev/null | grep -E "^version:" | head -1 | sed 's/version:[[:space:]]*["'"'"']\?\([^"'"'"'+]*\).*/\1/' | sed 's/-dev.*//')

		if [ -n "$LATEST_STABLE" ]; then
			# For DEV versions: Check if there are newer commits for this addon
			if [[ "$VERSION" == *"-dev"* ]]; then
				if [ -n "$DEV_COMMIT" ]; then
					# Get latest commit for this addon from GitHub
					local LATEST_COMMIT
					LATEST_COMMIT=$(curl -s --max-time 10 "https://api.github.com/repos/$REPO/commits?path=$SLUG&per_page=1" 2>/dev/null | grep -o '"sha": "[^"]*"' | head -1 | cut -d'"' -f4 | head -c7)

					if [ -n "$LATEST_COMMIT" ] && [ "$LATEST_COMMIT" != "$DEV_COMMIT" ]; then
						UPDATE_MSG="‚¨ÜÔ∏è  DEV UPDATE: New commits available"
						bashio::log.yellow "   Your commit: $DEV_COMMIT"
						bashio::log.yellow "   Latest: $LATEST_COMMIT"
					fi
				fi

				# Also check if a stable release is available
				if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
					# Compare versions
					if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
						bashio::log.yellow "   Consider upgrading to the stable release"
					fi
				fi

			# For BETA versions (< 1.0.0): Check for newer beta OR stable
			elif [[ "${BASE_VERSION%%.*}" =~ ^[0-9]+$ ]] && [ "${BASE_VERSION%%.*}" -lt 1 ] 2>/dev/null; then
				if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
					# If stable is >= 1.0.0, it's definitely newer
					local LATEST_MAJOR="${LATEST_STABLE%%.*}"
					if [ "$LATEST_MAJOR" -ge 1 ] 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  STABLE RELEASE: $LATEST_STABLE available!"
					elif version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
					fi
				fi

			# For STABLE versions: Simple version comparison
			else
				if [ "$LATEST_STABLE" != "$BASE_VERSION" ]; then
					if version_gt "$LATEST_STABLE" "$BASE_VERSION" 2>/dev/null; then
						UPDATE_MSG="‚¨ÜÔ∏è  UPDATE AVAILABLE: $LATEST_STABLE"
					fi
				fi
			fi
		fi

		if [ -n "$UPDATE_MSG" ]; then
			bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
			bashio::log.yellow "$UPDATE_MSG"
			bashio::log.yellow "   You are running: $VERSION"
			bashio::log.yellow "   Update via the Add-on Store"
			bashio::log.yellow "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
		fi
	fi

	# Footer with links
	bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	bashio::log.info "üìù Issues: https://github.com/$REPO/issues"
	bashio::log.info "üíñ Maintained by: $MAINTAINER"
	bashio::log.blue "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
	bashio::log.info ""
}

# Show banner on startup
if type bashio::log.blue &>/dev/null 2>&1; then
	_show_startup_banner
fi

# </ADDON_BANNER_INJECTION>

firmware_path=$(bashio::config 'firmware_path')
firmware_name=$(bashio::config 'firmware_name')
firmware_name_new=r3600-raw-img.bin
rm1800=false

if [ ! -f "$firmware_path$firmware_name" ]; then
	echo "$firmware_path$firmware_name does not exist. Exiting..."
	exit
fi

if [[ "$firmware_name" == *"rm1800"* ]] || [[ "$firmware_name" == *"ax1800"* ]]; then
	firmware_name_new_rm1800="rm1800-raw-img.bin"
	rm1800=true
	echo "Detected rm1800 firmware name. Will append --data to ubinze.sh script"
else
	echo "Did not detect a rm1800 firmware, will start the process with the default xqrepack settings."
	echo "If you tried to use it with a rm1800 image, do NOT flash the image and restart the addon with the firmware_name rm1800 inside."
fi

cd /xqrepack || exit

echo "Extracting Firmware Image $firmware_path$firmware_name"
ubireader_extract_images -w "$firmware_path$firmware_name"

echo "-------------------------------------------------------------"
echo "Patch the rootfs using the @geekman repack-squashfs.sh script"
rootfs_name=$(find "./ubifs-root/$firmware_name/" -maxdepth 1 -name "*vol-ubi_rootfs.ubifs*" -print)
echo "Rootfs was detected: $rootfs_name"
chmod -R 755 ./
chmod -R 755 /tmp/
fakeroot -- ./repack-squashfs.sh "$rootfs_name"

echo "-------------------------------------------------------------"
echo "Recombine the kernel and patched rootfs with @geekman ubinize.sh"
rootfs_kernel_name=$(find "./ubifs-root/$firmware_name/" -maxdepth 1 -name "*vol-kernel.ubifs*" -print)
echo "rootfs_kernel_name was detected: $rootfs_kernel_name"
rootfs_new_name=$(find "./ubifs-root/$firmware_name/" -maxdepth 1 -name "*ubi_rootfs.ubifs.new*" -print)
echo "rootfs_new_name was detected: $rootfs_new_name"
chmod -R 755 ./
if [ "$rm1800" = "true" ]; then
	echo "starting ubinize.sh with --data for the rm1800 image now..."
	./ubinize.sh "$rootfs_kernel_name" "$rootfs_new_name" --data
else
	echo "starting ubinize.sh for the r3600 image now..."
	./ubinize.sh "$rootfs_kernel_name" "$rootfs_new_name"
fi

echo "-------------------------------------------------------------"
if [ "$rm1800" = "true" ]; then
	echo "Copying new firmware file $firmware_name_new to $firmware_path$firmware_name_new_rm1800"
	if test -f "$firmware_path$firmware_name_new_rm1800"; then
		echo "$firmware_path$firmware_name_new_rm1800 exists already, deleting old firmware image!"
		rm "$firmware_path$firmware_name_new_rm1800"
	fi
	mv "$firmware_name_new" "$firmware_path$firmware_name_new_rm1800"
else
	echo "Copying new firmware file $firmware_name_new to $firmware_path"
	if test -f "$firmware_path$firmware_name_new"; then
		echo "$firmware_path$firmware_name_new exists already, deleting old firmware image!"
		rm "$firmware_path$firmware_name_new"
	fi
	mv "$firmware_name_new" "$firmware_path"
fi
