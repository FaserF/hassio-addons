name: Orchestrator Labeler

permissions:
  contents: read
  pull-requests: write
  issues: write

on:
  pull_request:
    branches:
      - master
    types: [opened, synchronize, reopened]

# Prevent multiple labeler runs from fighting over labels
concurrency:
  group: labeler-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  label:
    runs-on: ubuntu-latest
    steps:
      - name: â¤µï¸ Check out code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: ðŸ·ï¸ Dynamic Labeler
        uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // 1. Identify Total Apps in Repo from BASE BRANCH (not PR branch)
            // This ensures "All Apps" is calculated against the target state, not the PR
            const baseRef = context.payload.pull_request.base.ref;

            // Get Apps from base branch via git
            const { execSync } = require('child_process');
            let baseApps = [];
            try {
                const lsTree = execSync(`git ls-tree --name-only origin/${baseRef}`, { encoding: 'utf8' });
                baseApps = lsTree.split('\n').filter(name => {
                    if (!name || name.startsWith('.')) return false;
                    // Check if this dir has config.yaml in base branch
                    try {
                        execSync(`git cat-file -e origin/${baseRef}:${name}/config.yaml`, { stdio: 'pipe' });
                        return true;
                    } catch {
                        return false;
                    }
                });
            } catch (e) {
                console.log('Failed to get base branch Apps, falling back to current checkout');
                const rootEntries = fs.readdirSync('.', { withFileTypes: true });
                baseApps = rootEntries.filter(dirent => {
                    if (!dirent.isDirectory()) return false;
                    if (dirent.name.startsWith('.')) return false;
                    return fs.existsSync(path.join(dirent.name, 'config.yaml'));
                }).map(d => d.name);
            }

            const totalApps = baseApps;

            console.log(`Total Supported Apps Detected: ${totalApps.length}`);
            console.log(`App list: ${totalApps.join(', ')}`);

            // Blocklist of known non-App directories
            const BLOCKLIST = ['docker', 'config', 'scripts', 'docs', 'images', 'assets', 'src', 'lib', 'bin', 'test', 'tests', 'node_modules'];

            // Sanity check: filter out any obviously wrong entries
            const validAppPattern = /^[a-zA-Z][a-zA-Z0-9_-]*$/;
            const validApps = totalApps.filter(name => {
                if (BLOCKLIST.includes(name.toLowerCase())) {
                    console.log(`Warning: Blocklisted name filtered: ${name}`);
                    return false;
                }
                if (!validAppPattern.test(name)) {
                // ... (abbreviated context) ...
                    console.log(`Warning: Invalid App name detected and filtered: ${name}`);
                    return false;
                }
                return true;
            });
            console.log(`Valid Apps after filtering: ${validApps.join(', ')}`);

            // 2. Identify Changed Files (with Pagination)
            const changedFiles = [];
            let page = 1;
            while (true) {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                per_page: 100,
                page: page
              });
              if (files.length === 0) break;
              changedFiles.push(...files);
              page++;
            }

            console.log(`Total changed files found: ${changedFiles.length}`);
            const changedApps = new Set();
            const labelsToAdd = new Set();
            const newApps = new Set(); // Track new Apps that don't exist in base branch
            let hasVersionBump = false;
            const versionBumpApps = [];

            // 3. Map Changes to Apps
            console.log("=== Changed files analysis ===");
            // Track potential new Apps by directory
            const potentialNewApps = new Map(); // dir -> {hasConfig: bool, fileCount: number, allAdded: bool}

            for (const file of changedFiles) {
              const parts = file.filename.split('/');
              if (parts.length > 1) {
                const rootDir = parts[0];
                console.log(`File: ${file.filename} -> rootDir: ${rootDir}`);

                // Initialize tracking for this directory
                if (!potentialNewApps.has(rootDir)) {
                    potentialNewApps.set(rootDir, {
                        hasConfig: false,
                        fileCount: 0,
                        allAdded: true
                    });
                }
                const tracking = potentialNewApps.get(rootDir);
                tracking.fileCount++;

                // Check if file was added (not modified or deleted)
                if (file.status !== 'added') {
                    tracking.allAdded = false;
                }

                // Check if this is config.yaml
                if (file.filename.endsWith('/config.yaml') || file.filename === `${rootDir}/config.yaml`) {
                    tracking.hasConfig = true;
                }

                // Track Supported Apps (with blocklist check)
                if (validApps.includes(rootDir) && !BLOCKLIST.includes(rootDir.toLowerCase())) {
                    changedApps.add(rootDir);
                    labelsToAdd.add(`App/${rootDir}`);
                    console.log(`  -> Added as supported App: ${rootDir}`);
                }

                // Track Unsupported Apps (Label individually, don't count towards "All Supported")
                if (rootDir === '.unsupported' && parts.length > 2) {
                    const unsupApp = parts[1];
                    // Verify existence of config.yaml and not in blocklist
                    if (!BLOCKLIST.includes(unsupApp.toLowerCase()) && fs.existsSync(path.join('.', '.unsupported', unsupApp, 'config.yaml'))) {
                        labelsToAdd.add(`App/${unsupApp}`);
                        console.log(`  -> Added as unsupported App: ${unsupApp}`);
                    }
                }

                // 3a. Detect Version Bumps in config.yaml
                if (file.filename.endsWith('config.yaml') && file.patch) {
                    // Check if version line was modified
                    const versionChangePattern = /^\+\s*version:\s*["']?[\d.]+["']?/m;
                    if (versionChangePattern.test(file.patch)) {
                        // Determine which App
                        let AppName = rootDir;
                        if (rootDir === '.unsupported' && parts.length > 2) {
                            AppName = parts[1];
                        }

                        // Only consider it a version bump if the App already exists in base branch
                        // New Apps shouldn't get version-bump label (they have initial version, not a bump)
                        let isNewApp = false;

                        if (rootDir === '.unsupported' && parts.length > 2) {
                            // For unsupported Apps, check if the App exists in base branch
                            try {
                                execSync(`git cat-file -e origin/${baseRef}:.unsupported/${AppName}/config.yaml`, { stdio: 'pipe' });
                                // File exists in base branch, so it's not new
                                isNewApp = false;
                            } catch {
                                // File doesn't exist in base branch, so it's a new App
                                isNewApp = true;
                            }
                        } else {
                            // For supported Apps, check if App exists in baseApps
                            isNewApp = !baseApps.includes(rootDir);
                        }

                        if (!isNewApp) {
                            hasVersionBump = true;
                            versionBumpApps.push(AppName);
                            console.log(`  -> Version bump detected in: ${AppName}`);
                        } else {
                            console.log(`  -> Version line added in new App ${AppName}, skipping version-bump label`);
                        }
                    }
                }
              }
            }

            // After processing all files, check for new Apps
            for (const [rootDir, tracking] of potentialNewApps.entries()) {
                // Check if this is a new App (not in base branch, has config.yaml, valid name)
                const isNewApp = !baseApps.includes(rootDir) &&
                                   !BLOCKLIST.includes(rootDir.toLowerCase()) &&
                                   rootDir !== '.unsupported' &&
                                   validAppPattern.test(rootDir) &&
                                   tracking.hasConfig &&
                                   fs.existsSync(path.join(rootDir, 'config.yaml'));

                if (isNewApp && !changedApps.has(rootDir)) {
                    changedApps.add(rootDir);
                    labelsToAdd.add(`App/${rootDir}`);
                    newApps.add(rootDir);
                    console.log(`  -> Detected NEW App: ${rootDir} (${tracking.fileCount} files, not in base branch)`);
                }
            }

            // Add version-bump label if detected
            if (hasVersionBump) {
                labelsToAdd.add('version-bump');
                console.log(`Version bumps detected in: ${versionBumpApps.join(', ')}`);
            }

            console.log(`Changed Supported Apps: ${changedApps.size}`);

            // 4. Determine Managed Labels (What *should* be there)
            const newManagedLabels = new Set();

            if (validApps.length > 0 && changedApps.size === validApps.length) {
                console.log("Triggering 'All Apps' Label");
                newManagedLabels.add("All Apps");
            }
            else if (changedApps.size > 8) {
                console.log(`Triggering 'Many Apps' Label (Changed: ${changedApps.size})`);
                newManagedLabels.add("Many Apps");
            }
            else {
                // Individual labels
                for (const App of labelsToAdd) {
                    if (App !== 'version-bump') { // version-bump is handled separately
                        newManagedLabels.add(App);
                    }
                }
            }

            // Always add version-bump if detected (regardless of All/Many Apps)
            if (hasVersionBump) {
                newManagedLabels.add('version-bump');
                console.log(`Added 'version-bump' label for: ${versionBumpApps.join(', ')}`);
            }

            // Add new-App label if any new Apps detected
            if (newApps.size > 0) {
                newManagedLabels.add('new-App');
                console.log(`Added 'new-App' label for: ${Array.from(newApps).join(', ')}`);
            }

            // 5. Fetch, Merge, and Set Labels
            // Fetch current labels to preserve manual ones (e.g., "help wanted")
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
            });

            console.log("Current Labels:", currentLabels.map(l => l.name));

            // Filter out existing "Managed" labels (stale ones)
            // Managed = starts with "App/" OR "All Apps" OR "Many Apps" OR "version-bump" OR "new-App"
            const preservedLabels = currentLabels.map(l => l.name).filter(name => {
                if (name === "All Apps") return false;
                if (name === "Many Apps") return false;
                if (name === "version-bump") return false;
                if (name === "new-App") return false;
                if (name.startsWith("App/")) return false;
                if (name.startsWith("size/")) return false;
                return true;
            });

            // Combine Preserved + New Managed
            let finalLabels = [...preservedLabels, ...newManagedLabels];

            // FINAL SAFETY CHECK: Remove any App/* labels that don't match known valid Apps
            finalLabels = finalLabels.filter(label => {
                if (label.startsWith('App/')) {
                    const AppName = label.replace('App/', '');
                    if (BLOCKLIST.includes(AppName.toLowerCase())) {
                        console.log(`BLOCKED invalid label: ${label}`);
                        return false;
                    }
                }
                return true;
            });

            console.log("Final Labels:", finalLabels);

            // ================================================================
            // SEMANTIC LABELING: Detect PR characteristics
            // ================================================================

            // Get PR title and body for semantic analysis
            const prTitle = context.payload.pull_request.title.toLowerCase();
            const prBody = (context.payload.pull_request.body || '').toLowerCase();
            const combinedText = `${prTitle} ${prBody}`;

            // Breaking Change Detection
            if (combinedText.includes('breaking') || prTitle.includes('!:')) {
                finalLabels.push('breaking-change');
                console.log("Added 'breaking-change' label");
            }

            // Semantic Version Labels (from conventional commits)
            if (prTitle.startsWith('feat') || prTitle.includes('feature')) {
                finalLabels.push('enhancement');
                console.log("Added 'enhancement' label");
            }
            if (prTitle.startsWith('fix') || prTitle.includes('bugfix')) {
                finalLabels.push('bug');
                console.log("Added 'bug' label");
            }
            if (prTitle.startsWith('docs') || prTitle.includes('documentation')) {
                finalLabels.push('documentation');
                console.log("Added 'documentation' label");
            }
            if (prTitle.startsWith('security') || combinedText.includes('cve-') || combinedText.includes('vulnerability')) {
                finalLabels.push('security');
                console.log("Added 'security' label");
            }
            if (prTitle.startsWith('perf') || combinedText.includes('performance')) {
                finalLabels.push('performance');
                console.log("Added 'performance' label");
            }

            // Size Labels (based on changes)
            const additions = context.payload.pull_request.additions || 0;
            const deletions = context.payload.pull_request.deletions || 0;
            const totalChanges = additions + deletions;

            if (totalChanges <= 10) {
                finalLabels.push('size/XS');
            } else if (totalChanges <= 50) {
                finalLabels.push('size/S');
            } else if (totalChanges <= 200) {
                finalLabels.push('size/M');
            } else if (totalChanges <= 500) {
                finalLabels.push('size/L');
            } else {
                finalLabels.push('size/XL');
            }
            console.log(`Added size label for ${totalChanges} changes`);

            // Dependency Updates (Renovate/Dependabot)
            const prAuthor = context.payload.pull_request.user.login;
            if (prAuthor === 'renovate[bot]' || prAuthor === 'dependabot[bot]') {
                if (!finalLabels.includes('dependencies')) {
                    finalLabels.push('dependencies');
                }
                finalLabels.push('automerge');
                console.log("Added dependency bot labels");
            }

            // CI/Workflow changes
            const hasWorkflowChanges = changedFiles.some(f =>
                f.filename.startsWith('.github/')
            );
            if (hasWorkflowChanges) {
                finalLabels.push('ci');
                console.log("Added 'ci' label");
            }

            // Unsupported App detection
            const hasUnsupportedChanges = changedFiles.some(f =>
                f.filename.startsWith('.unsupported/')
            );
            if (hasUnsupportedChanges) {
                finalLabels.push('unsupported');
                console.log("Added 'unsupported' label");
            }

            // Remove duplicates
            finalLabels = [...new Set(finalLabels)];

            console.log("Final Labels with semantics:", finalLabels);

            // Compare with current labels to avoid unnecessary API calls
            const currentLabelNames = currentLabels.map(l => l.name).sort();
            const newLabelNames = [...finalLabels].sort();

            if (JSON.stringify(currentLabelNames) === JSON.stringify(newLabelNames)) {
                console.log("Labels unchanged, skipping API call");
            } else {
                console.log("Labels changed, updating via API");
                // Set Labels (Atomic Update)
                try {
                    await github.rest.issues.setLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: context.issue.number,
                        labels: finalLabels
                    });
                } catch (error) {
                    console.error("Failed to set labels: " + error.message);
                    core.setFailed("Failed to set labels: " + error.message);
                }
            }
