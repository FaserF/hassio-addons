name: Orchestrator Labeler

on:
  pull_request:
    branches:
      - master
    types: [opened, synchronize, reopened]

jobs:
  label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: â¤µï¸ Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ðŸ·ï¸ Dynamic Labeler
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // 1. Identify Total Add-ons in Repo from BASE BRANCH (not PR branch)
            // This ensures "All Add-ons" is calculated against the target state, not the PR
            const baseRef = context.payload.pull_request.base.ref;

            // Get add-ons from base branch via git
            const { execSync } = require('child_process');
            let baseAddons = [];
            try {
                const lsTree = execSync(`git ls-tree --name-only origin/${baseRef}`, { encoding: 'utf8' });
                baseAddons = lsTree.split('\n').filter(name => {
                    if (!name || name.startsWith('.')) return false;
                    // Check if this dir has config.yaml in base branch
                    try {
                        execSync(`git cat-file -e origin/${baseRef}:${name}/config.yaml`, { stdio: 'pipe' });
                        return true;
                    } catch {
                        return false;
                    }
                });
            } catch (e) {
                console.log('Failed to get base branch addons, falling back to current checkout');
                const rootEntries = fs.readdirSync('.', { withFileTypes: true });
                baseAddons = rootEntries.filter(dirent => {
                    if (!dirent.isDirectory()) return false;
                    if (dirent.name.startsWith('.')) return false;
                    return fs.existsSync(path.join(dirent.name, 'config.yaml'));
                }).map(d => d.name);
            }

            const totalAddons = baseAddons;

            console.log(`Total Supported Add-ons Detected: ${totalAddons.length}`);
            console.log(`Add-on list: ${totalAddons.join(', ')}`);

            // Blocklist of known non-addon directories that might appear
            const blocklist = ['docker', 'config', 'scripts', 'docs', 'images', 'assets', 'src', 'lib', 'bin', 'test', 'tests'];

            // Sanity check: filter out any obviously wrong entries
            const validAddonPattern = /^[a-zA-Z][a-zA-Z0-9_-]*$/;
            const validAddons = totalAddons.filter(name => {
                if (blocklist.includes(name.toLowerCase())) {
                    console.log(`Warning: Blocklisted name filtered: ${name}`);
                    return false;
                }
                if (!validAddonPattern.test(name)) {
                    console.log(`Warning: Invalid addon name detected and filtered: ${name}`);
                    return false;
                }
                return true;
            });
            console.log(`Valid Add-ons after filtering: ${validAddons.join(', ')}`);

            // 2. Identify Changed Files (with Pagination)
            const changedFiles = [];
            let page = 1;
            while (true) {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                per_page: 100,
                page: page
              });
              if (files.length === 0) break;
              changedFiles.push(...files);
              page++;
            }

            console.log(`Total changed files found: ${changedFiles.length}`);
            const changedAddons = new Set();
            const labelsToAdd = new Set();
            let hasVersionBump = false;
            const versionBumpAddons = [];

            // 3. Map Changes to Add-ons
            console.log("=== Changed files analysis ===");
            for (const file of changedFiles) {
              const parts = file.filename.split('/');
              if (parts.length > 1) {
                const rootDir = parts[0];
                console.log(`File: ${file.filename} -> rootDir: ${rootDir}`);

                // Track Supported Addons
                if (validAddons.includes(rootDir)) {
                    changedAddons.add(rootDir);
                    labelsToAdd.add(`addon/${rootDir}`);
                    console.log(`  -> Added as supported addon: ${rootDir}`);
                }

                // Track Unsupported Addons (Label individually, don't count towards "All Supported")
                if (rootDir === '.unsupported' && parts.length > 2) {
                    const unsupAddon = parts[1];
                    // Verify existence of config.yaml to confirm it is an add-on
                    if (fs.existsSync(path.join('.', '.unsupported', unsupAddon, 'config.yaml'))) {
                        labelsToAdd.add(`addon/${unsupAddon}`);
                        console.log(`  -> Added as unsupported addon: ${unsupAddon}`);
                    }
                }

                // 3a. Detect Version Bumps in config.yaml
                if (file.filename.endsWith('config.yaml') && file.patch) {
                    // Check if version line was modified
                    const versionChangePattern = /^\+\s*version:\s*["']?[\d.]+["']?/m;
                    if (versionChangePattern.test(file.patch)) {
                        hasVersionBump = true;
                        // Determine which addon
                        let addonName = rootDir;
                        if (rootDir === '.unsupported' && parts.length > 2) {
                            addonName = parts[1];
                        }
                        versionBumpAddons.push(addonName);
                        console.log(`  -> Version bump detected in: ${addonName}`);
                    }
                }
              }
            }

            // Add version-bump label if detected
            if (hasVersionBump) {
                labelsToAdd.add('version-bump');
                console.log(`Version bumps detected in: ${versionBumpAddons.join(', ')}`);
            }

            console.log(`Changed Supported Add-ons: ${changedAddons.size}`);

            // 4. Determine Managed Labels (What *should* be there)
            const newManagedLabels = new Set();

            if (validAddons.length > 0 && changedAddons.size === validAddons.length) {
                console.log("Triggering 'All Add-ons' Label");
                newManagedLabels.add("All Add-ons");
            }
            else if (changedAddons.size > 8) {
                console.log(`Triggering 'Many Add-ons' Label (Changed: ${changedAddons.size})`);
                newManagedLabels.add("Many Add-ons");
            }
            else {
                // Individual labels
                for (const addon of labelsToAdd) {
                    if (addon !== 'version-bump') { // version-bump is handled separately
                        newManagedLabels.add(addon);
                    }
                }
            }

            // Always add version-bump if detected (regardless of All/Many Add-ons)
            if (hasVersionBump) {
                newManagedLabels.add('version-bump');
                console.log(`Added 'version-bump' label for: ${versionBumpAddons.join(', ')}`);
            }

            // 5. Fetch, Merge, and Set Labels
            // Fetch current labels to preserve manual ones (e.g., "help wanted")
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
            });

            // Filter out existing "Managed" labels (stale ones)
            // Managed = starts with "addon/" OR "All Add-ons" OR "Many Add-ons" OR "version-bump"
            const preservedLabels = currentLabels.map(l => l.name).filter(name => {
                if (name === "All Add-ons") return false;
                if (name === "Many Add-ons") return false;
                if (name === "version-bump") return false;
                if (name.startsWith("addon/")) return false;
                return true;
            });

            // Combine Preserved + New Managed
            let finalLabels = [...preservedLabels, ...newManagedLabels];

            // FINAL SAFETY CHECK: Remove any addon/* labels that don't match known valid addons
            const hardcodedBlocklist = ['docker', 'config', 'scripts', 'docs', 'images', 'assets', 'node_modules'];
            finalLabels = finalLabels.filter(label => {
                if (label.startsWith('addon/')) {
                    const addonName = label.replace('addon/', '');
                    if (hardcodedBlocklist.includes(addonName.toLowerCase())) {
                        console.log(`BLOCKED invalid label: ${label}`);
                        return false;
                    }
                }
                return true;
            });

            console.log("Final Labels:", finalLabels);

            // Set Labels (Atomic Update: Removes stale managed, keeps manual, adds new managed)
            await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: finalLabels
            });
