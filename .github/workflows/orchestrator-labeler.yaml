name: Orchestrator Labeler

on:
  pull_request:
    branches:
      - master
    types: [opened, synchronize, reopened]

jobs:
  label:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: â¤µï¸ Check out code
        uses: actions/checkout@v4

      - name: ðŸ·ï¸ Dynamic Labeler
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // 1. Identify Total Add-ons in Repo (Supported only? Or all?)
            // "All Add-ons" usually implies the active, supported suite.
            // We scan root folders for 'config.yaml'.
            const rootEntries = fs.readdirSync('.', { withFileTypes: true });
            const totalAddons = rootEntries.filter(dirent => {
                if (!dirent.isDirectory()) return false;
                if (dirent.name.startsWith('.')) return false; // Ignore .github, .scripts, .unsupported (unless user wants them)
                // Check for config.yaml
                return fs.existsSync(path.join(dirent.name, 'config.yaml'));
            }).map(d => d.name);

            console.log(`Total Supported Add-ons Detected: ${totalAddons.length}`);

            // 2. Identify Changed Files (with Pagination)
            const changedFiles = [];
            let page = 1;
            while (true) {
              const { data: files } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                per_page: 100,
                page: page
              });
              if (files.length === 0) break;
              changedFiles.push(...files);
              page++;
            }

            console.log(`Total changed files found: ${changedFiles.length}`);
            const changedAddons = new Set();

            // 3. Map Changes to Add-ons
            for (const file of changedFiles) {
              const parts = file.filename.split('/');
              if (parts.length > 1) {
                const rootDir = parts[0];

                // Track Supported Addons
                if (totalAddons.includes(rootDir)) {
                    changedAddons.add(rootDir);
                    labelsToAdd.add(`addon/${rootDir}`);
                }

                // Track Unsupported Addons (Label individually, don't count towards "All Supported")
                if (rootDir === '.unsupported' && parts.length > 2) {
                    const unsupAddon = parts[1];
                    // Verify existence of config.yaml to confirming it is an add-on
                    if (fs.existsSync(path.join('.', '.unsupported', unsupAddon, 'config.yaml'))) {
                        labelsToAdd.add(`addon/${unsupAddon}`);
                    }
                }
              }
            }

            console.log(`Changed Supported Add-ons: ${changedAddons.size}`);

            // 4. Determine Managed Labels (What *should* be there)
            const newManagedLabels = new Set();

            if (totalAddons.length > 0 && changedAddons.size === totalAddons.length) {
                console.log("Triggering 'All Add-ons' Label");
                newManagedLabels.add("All Add-ons");
            }
            else if (changedAddons.size > 8) {
                console.log(`Triggering 'Many Add-ons' Label (Changed: ${changedAddons.size})`);
                newManagedLabels.add("Many Add-ons");
            }
            else {
                // Individual labels
                for (const addon of labelsToAdd) {
                    newManagedLabels.add(addon);
                }
            }

            // 5. Fetch, Merge, and Set Labels
            // Fetch current labels to preserve manual ones (e.g., "help wanted")
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
            });

            // Filter out existing "Managed" labels (stale ones)
            // Managed = starts with "addon/" OR "All Add-ons" OR "Many Add-ons"
            const preservedLabels = currentLabels.map(l => l.name).filter(name => {
                if (name === "All Add-ons") return false;
                if (name === "Many Add-ons") return false;
                if (name.startsWith("addon/")) return false;
                return true;
            });

            // Combine Preserved + New Managed
            const finalLabels = [...preservedLabels, ...newManagedLabels];

            console.log("Final Labels:", finalLabels);

            // Set Labels (Atomic Update: Removes stale managed, keeps manual, adds new managed)
            await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: finalLabels
            });
