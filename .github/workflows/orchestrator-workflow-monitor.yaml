name: Orchestrator Workflow Monitor

on:
  # Trigger when any workflow completes
  workflow_run:
    workflows:
      - "Orchestrator Auto-Fix"
      - "Orchestrator Auto-Merge"
      - "Orchestrator CI"
      - "Cleanup PR Artifacts"
      - "Orchestrator Docs & Standards"
      - "Orchestrator Governance"
      - "Orchestrator New Add-on Intake"
      - "Orchestrator Labeler"
      - "Orchestrator Maintenance"
      - "Orchestrator Release"
      - "Orchestrator Updates"
    types:
      - completed
  # Trigger on PR changes to workflow files (for linting)
  pull_request:
    branches:
      - master
      - ".github/workflows/**"
      - ".github/actionlint.yaml"
  # Allow manual trigger with optional quota override
  workflow_dispatch:
    inputs:
      monthly_quota:
        description: 'Monthly Runner Minutes Quota (Override)'
        required: false
        default: ''

concurrency:
  group: workflow-monitor-${{ github.event.workflow_run.id || github.run_id }}
  cancel-in-progress: false

jobs:
  # --------------------------------------------------------------------------------
  # LINT: Validate Workflow Files with actionlint
  # --------------------------------------------------------------------------------
  lint-workflows:
    name: üîç Lint Workflow Files
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4

      - name: üßπ Run actionlint
        id: actionlint
        uses: raven-actions/actionlint@v2
        with:
          matcher: true
          fail-on-error: false

      - name: üìù Post Lint Report on Failure
        if: steps.actionlint.outputs.exit-code != '0'
        uses: actions/github-script@v7
        env:
          ACTIONLINT_OUTPUT: ${{ steps.actionlint.outputs.stdout }}
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const signature = "<!-- workflow-lint-report -->";
            const previousComments = comments.filter(c => c.user.type === 'Bot' && c.body.includes(signature));

            // Minimize old lint reports
            for (const comment of previousComments) {
              try {
                await github.graphql(`
                  mutation($subjectId: ID!) {
                    minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                      minimizedComment { isMinimized }
                    }
                  }
                `, { subjectId: comment.node_id });
              } catch (e) { console.log("Could not minimize:", e.message); }
            }

            let body = signature + "\n";
            body += "## üîß Workflow Lint Errors\n\n";
            body += "The following issues were found in the workflow files:\n\n";
            body += "```\n";
            body += process.env.ACTIONLINT_OUTPUT || 'See workflow logs for details.';
            body += "\n```\n\n";
            body += "<details>\n<summary>ü§ñ <strong>AI Summary (Fix Suggestions)</strong></summary>\n\n";
            body += "> [!TIP]\n> **Common Fixes**\n>\n";
            body += "> - **Syntax errors**: Check YAML indentation and quoting\n";
            body += "> - **Unknown actions**: Verify action versions exist (e.g., `actions/checkout@v4`)\n";
            body += "> - **Expression errors**: Check `${{ }}` syntax and available contexts\n";
            body += "> - **Deprecated features**: Update to latest GitHub Actions syntax\n\n";
            body += "</details>\n\n";
            body += "üìö [actionlint documentation](https://github.com/rhysd/actionlint)\n";

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

            // Add label
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            if (!currentLabels.some(l => l.name === 'workflow/lint-error')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['workflow/lint-error']
              });
            }

      - name: ‚ùå Fail on Lint Errors
        if: steps.actionlint.outputs.exit-code != '0'
        run: exit 1

  # --------------------------------------------------------------------------------
  # CHECK: GitHub Actions Runner Minutes
  # --------------------------------------------------------------------------------
  check-runner-minutes:
    name: ‚è±Ô∏è Check Runner Minutes
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: üìä Check GitHub Actions Billing
        id: billing
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Try organization billing first
              let response;
              try {
                response = await github.rest.billing.getGithubActionsBillingOrg({
                  org: context.repo.owner
                });
              } catch (orgError) {
                // Fall back to user billing
                response = await github.rest.billing.getGithubActionsBillingUser({
                  username: context.repo.owner
                });
              }

              const used = response.data.total_minutes_used || 0;

              // Determine quota
              let quota = 2000; // Default fallback (Free/Public)

              // 1. Check for manual override input
              const manualQuota = context.payload.inputs ? context.payload.inputs.monthly_quota : null;
              if (manualQuota && !isNaN(parseInt(manualQuota))) {
                  quota = parseInt(manualQuota);
                  console.log(`Using manual quota override: ${quota}`);
              }
              // 2. Check API included_minutes
              else if (response.data.included_minutes) {
                  quota = response.data.included_minutes;
              }
              // 3. Infer from Plan/Account Type (if API didn't return included_minutes)
              else {
                  // Not all endpoints return plan info directly in the same structure,
                  // but we try to make a best guess if included_minutes is missing.
                  // For User accounts, it's usually 2000 (Free) or 3000 (Pro).
                  // For Orgs, it varies (Free=2000, Team=3000, Enterprise=50000).

                  // Note: The billing API response structure varies by endpoint (User vs Org).
                  // We'll stick to the safe default of 2000 unless we can verify Pro/Team/Enterprise.
                  // Since we can't reliably see 'plan' object in all responses here without more calls,
                  // we rely on included_minutes or the default.
                  // However, per user request, we set specific defaults if we could detect it.
                  // Assuming standard GitHub plans:
                  // Free: 2000
                  // Pro/Team: 3000
                  // Enterprise: 50000

                  // If we had plan info:
                  // if (plan === 'pro' || plan === 'team') quota = 3000;
                  // if (plan === 'enterprise') quota = 50000;

                  console.log("Using default/detected quota: " + quota);
              }
              const remaining = quota - used;
              const percentage = Math.round((remaining / quota) * 100);

              console.log(`Minutes Used: ${used}/${quota}`);
              console.log(`Remaining: ${remaining} (${percentage}%)`);

              let status = "ok";
              let message = "";

              if (remaining <= 0) {
                status = "exhausted";
                message = `üõë **CRITICAL**: All GitHub Actions minutes exhausted! (${used}/${quota} used)`;
              } else if (remaining < 100) {
                status = "critical";
                message = `üõë **CRITICAL**: Only ${remaining} of ${quota} minutes remaining (${percentage}%)!`;
              } else if (remaining < 500) {
                status = "warning";
                message = `‚ö†Ô∏è **WARNING**: Only ${remaining} of ${quota} minutes remaining (${percentage}%).`;
              }

              core.setOutput("status", status);
              core.setOutput("message", message);
              core.setOutput("remaining", remaining);
              core.setOutput("quota", quota);
              core.setOutput("used", used);

            } catch (error) {
              console.log("Could not fetch billing info:", error.message);
              core.setOutput("status", "unknown");
              core.setOutput("message", "");
            }

      - name: üìù Post Minutes Warning
        if: steps.billing.outputs.status == 'warning' || steps.billing.outputs.status == 'critical' || steps.billing.outputs.status == 'exhausted'
        uses: actions/github-script@v7
        env:
          BILLING_MESSAGE: ${{ steps.billing.outputs.message }}
          BILLING_STATUS: ${{ steps.billing.outputs.status }}
        with:
          script: |
            const message = process.env.BILLING_MESSAGE;
            const status = process.env.BILLING_STATUS;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const signature = "<!-- runner-minutes-warning -->";
            const previousComments = comments.filter(c => c.user.type === 'Bot' && c.body.includes(signature));

            // Minimize old warnings
            for (const comment of previousComments) {
                try {
                    await github.graphql(`
                        mutation($subjectId: ID!) {
                            minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                                minimizedComment { isMinimized }
                            }
                        }
                    `, { subjectId: comment.node_id });
                } catch (error) {
                    console.error(`Failed to minimize comment ${comment.id}:`, error);
                }
            }

            let body = signature + "\n";
            body += "## ‚è±Ô∏è GitHub Actions Minutes Warning\n\n";
            body += message + "\n\n";

            if (status === 'exhausted') {
              body += "> [!CAUTION]\n";
              body += "> Further workflow runs will fail until minutes reset next month.\n";
              body += "> Contact an administrator to increase the limit.\n";
            } else if (status === 'critical') {
              body += "> [!WARNING]\n";
              body += "> Minutes will be exhausted soon if usage continues.\n";
              body += "> Consider optimizing workflows or running less frequently.\n";
            } else {
              body += "> [!IMPORTANT]\n";
              body += "> Monitor usage to avoid interruptions.\n";
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: body
            });

            // Add label
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            if (!currentLabels.some(l => l.name === 'infra/low-minutes')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['infra/low-minutes']
              });
            }

  # --------------------------------------------------------------------------------
  # ANALYZE: Workflow Infrastructure Failures
  # --------------------------------------------------------------------------------
  analyze-workflow-failures:
    name: üî¨ Analyze Workflow Failures
    if: |
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.conclusion == 'failure'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      actions: read
    steps:
      - name: üìù Analyze and Report Infrastructure Errors
        uses: actions/github-script@v7
        with:
          script: |
            const workflowRun = context.payload.workflow_run;
            let prNumber = workflowRun.pull_requests[0]?.number;

            if (!prNumber) {
              console.log("No PR in payload, searching by SHA...");
              const { data: pullRequests } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: workflowRun.head_sha,
              });
              if (pullRequests.length > 0) {
                prNumber = pullRequests[0].number;
                console.log(`Found PR #${prNumber} associated with commit ${workflowRun.head_sha}`);
              }
            }

            if (!prNumber) {
              console.log("No PR associated with this workflow run.");
              return;
            }

            // Get jobs for the failed workflow run
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: workflowRun.id,
            });

            const failedJobs = jobs.jobs.filter(j => j.conclusion === 'failure');

            // Infrastructure error patterns (not project test failures)
            const infraPatterns = [
              { pattern: /action.*not found/i, type: "Action Not Found", fix: "Update action to an existing version" },
              { pattern: /version.*deprecated/i, type: "Deprecated Version", fix: "Update to a supported version" },
              { pattern: /runner.*unavailable/i, type: "Runner Unavailable", fix: "Check runner labels and availability" },
              { pattern: /timeout/i, type: "Timeout", fix: "Increase timeout or optimize the step" },
              { pattern: /rate limit/i, type: "Rate Limit", fix: "Wait and retry, or reduce API calls" },
              { pattern: /yaml.*error|syntax error/i, type: "YAML/Syntax Error", fix: "Run actionlint locally to fix syntax" },
              { pattern: /permission denied/i, type: "Permission Error", fix: "Check workflow permissions" },
              { pattern: /node.*version|unsupported.*node/i, type: "Node Version Issue", fix: "Update to Node.js 20" },
              { pattern: /docker.*error|container.*error/i, type: "Docker Error", fix: "Check Dockerfile and build context" },
              { pattern: /cancelled/i, type: "Workflow Cancelled", fix: "Investigate concurrent run conflicts" },
              { pattern: /unauthorized|authentication failed/i, type: "Auth Failure", fix: "Check secrets and permissions" },
              { pattern: /network.*error|connection.*refused/i, type: "Network Error", fix: "Retry or check external service status" },
              { pattern: /disk.*space|no space left/i, type: "Disk Space", fix: "Clean up runner or optimize build artifacts" },
              { pattern: /cache.*error|restore.*fail/i, type: "Cache Error", fix: "Clear cache or check keys" },
            ];

            // Analyze failures
            let infraErrors = [];
            let projectErrors = [];

            for (const job of failedJobs) {
              const failedStep = job.steps?.find(s => s.conclusion === 'failure');
              const stepName = failedStep?.name || "Unknown";

              // Check if this is an infrastructure error
              let isInfraError = false;
              let errorInfo = { job: job.name, step: stepName, type: "Unknown", fix: "Check logs" };

              // Check step name for patterns
              for (const { pattern, type, fix } of infraPatterns) {
                if (pattern.test(stepName) || pattern.test(job.name)) {
                  errorInfo.type = type;
                  errorInfo.fix = fix;
                  isInfraError = true;
                  break;
                }
              }

              // Known infrastructure steps
              const infraSteps = [
                'Check out code', 'Set up', 'Setup', 'Install', 'Cache',
                'Download', 'Upload', 'Docker', 'Login', 'Checkout'
              ];
              if (infraSteps.some(s => stepName.includes(s))) {
                isInfraError = true;
                errorInfo.type = "Setup/Infrastructure";
              }

              // Known project test steps (exclude from infra report)
              const testSteps = [
                'ShellCheck', 'Hadolint', 'MarkdownLint', 'YAMLLint', 'Prettier',
                'Add-on Linter', 'Compliance', 'Trivy', 'Build All', 'Test Build'
              ];
              if (testSteps.some(s => stepName.includes(s) || job.name.includes(s))) {
                projectErrors.push(errorInfo);
                continue; // Skip - this is a project test, not infra
              }

              if (isInfraError) {
                infraErrors.push(errorInfo);
              }
            }

            // Only report if there are infrastructure errors
            if (infraErrors.length === 0) {
              console.log("No infrastructure errors detected. Project test failures are handled by CI workflow.");
              return;
            }

            // Create report
            const signature = "<!-- workflow-infra-error -->";
            let body = signature + "\n";
            body += "## üîß Workflow Infrastructure Error\n\n";
            body += "An error occurred in the workflow infrastructure (not in project tests).\n\n";
            body += "| Job | Step | Error Type | Fix |\n|---|---|---|---|\n";

            for (const err of infraErrors) {
              body += `| ${err.job} | ${err.step} | ${err.type} | ${err.fix} |\n`;
            }

            body += "\n";
            body += "<details>\n<summary>ü§ñ <strong>AI Summary (Diagnosis)</strong></summary>\n\n";
            body += "> [!IMPORTANT]\n";
            body += "> **Workflow Infrastructure Errors** are not caused by code changes.\n";
            body += "> They typically require maintainer intervention.\n\n";
            body += "```text\n";
            body += `Affected Workflow: ${workflowRun.name}\n`;
            body += `Run ID: ${workflowRun.id}\n`;
            body += `Infrastructure Errors: ${infraErrors.length}\n`;
            if (projectErrors.length > 0) {
              body += `Project Test Failures: ${projectErrors.length} (handled separately)\n`;
            }
            body += "```\n";
            body += "\n</details>\n\n";
            body += `üîó [Workflow Logs](${workflowRun.html_url})\n`;

            // Check for existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            const previousComments = comments.filter(c =>
              c.user.type === 'Bot' && c.body.includes(signature)
            );

            // Minimize old reports
            for (const comment of previousComments) {
              try {
                await github.graphql(`
                  mutation($subjectId: ID!) {
                    minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                      minimizedComment { isMinimized }
                    }
                  }
                `, { subjectId: comment.node_id });
              } catch (e) { console.log("Could not minimize:", e.message); }
            }

            // Post new report
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });

            // Add label
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            if (!currentLabels.some(l => l.name === 'workflow/infra-error')) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                labels: ['workflow/infra-error']
              });
            }
