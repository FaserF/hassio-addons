name: Orchestrator Release

# Unified release workflow combining:
# - Manual releases (workflow_dispatch)
# - Auto-releases after Renovate PRs merge (pull_request.closed)
# - Repository dispatch from other workflows

on:
  workflow_dispatch:
    inputs:
      addon:
        description: "Add-on slug (folder name) or list (comma-separated), 'all' for all add-ons, or 'detect' for auto"
        required: true
        type: string
      version:
        description: "Version increment (major, minor, patch)"
        required: true
        default: "patch"
        type: choice
        options:
          - patch
          - minor
          - major
      custom_version:
        description: "Specific target version (e.g. 1.2.3). Overrides 'version' input."
        required: false
        type: string
      skip_verification:
        description: "Skip lint/build verification"
        required: false
        default: false
        type: boolean
      changelog_only:
        description: "Only update changelog, don't bump version (versions already correct)"
        required: false
        default: false
        type: boolean
      changelog_message:
        description: "Custom changelog message (optional)"
        required: false
        type: string

  pull_request:
    types: [closed]
    branches:
      - master

  repository_dispatch:
    types: [dependency-update, base-image-update, auto-release]

  push:
    branches:
      - master
    paths:
      - "**/config.yaml"
      - ".github/workflows/orchestrator-release.yaml"

permissions:
  contents: write
  packages: write
  actions: write
  pull-requests: read

env:
  # Addons to ignore for auto-releases (Blacklist)
  AUTO_RELEASE_IGNORE: |
    sap-abap-cloud-dev

  # Labels that indicate safe auto-release
  SAFE_LABELS: dependencies automerge

  # Labels that block auto-release
  BLOCK_LABELS: breaking-change major no-release needs-review

jobs:
  # ================================================================================
  # DETECT: Determine which addons need release
  # ================================================================================
  detect:
    name: üîç Detect Release Targets
    if: |
      github.event_name == 'pull_request' ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'repository_dispatch' ||
      (github.event_name == 'push' && contains(github.event.head_commit.message, 'release(all)'))
    runs-on: ubuntu-latest
    outputs:
      addons: ${{ steps.detect.outputs.addons }}
      should_release: ${{ steps.detect.outputs.should_release }}
      is_auto: ${{ steps.detect.outputs.is_auto }}
      version_type: ${{ steps.detect.outputs.version_type }}
      is_manual_bump: ${{ steps.detect.outputs.is_manual_bump }}
      is_all: ${{ steps.detect.outputs.is_all }}
      target_version: ${{ steps.detect.outputs.target_version }}
    steps:
      - name: ‚§µÔ∏è Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: üîç Detect release targets
        id: detect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_MERGED: ${{ github.event.pull_request.merged }}
          PR_LABELS: ${{ toJson(github.event.pull_request.labels.*.name) }}
          INPUT_ADDON: ${{ github.event.inputs.addon }}
          INPUT_VERSION: ${{ github.event.inputs.version }}
          INPUT_CUSTOM_VERSION: ${{ github.event.inputs.custom_version }}
          DISPATCH_ADDON: ${{ github.event.client_payload.addon }}
          DISPATCH_VERSION: ${{ github.event.client_payload.version }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          EVENT_NAME: ${{ github.event_name }}
          HEAD_COMMIT_MSG: ${{ github.event.head_commit.message }}
        run: |
          set -e
          ADDONS=""
          SHOULD_RELEASE="false"
          IS_AUTO="false"
          VERSION_TYPE="patch"
          TARGET_VERSION=""
          IS_ALL="false"

          # ----------------------------------------------------------------
          # MANUAL DISPATCH
          # ----------------------------------------------------------------
          if [ "$EVENT_NAME" == "workflow_dispatch" ]; then
            IS_AUTO="false"
            VERSION_TYPE="${INPUT_VERSION:-patch}"
            TARGET_VERSION="${INPUT_CUSTOM_VERSION}"

            if [ -n "$TARGET_VERSION" ]; then
                echo "üîç Custom target version provided: $TARGET_VERSION"
                VERSION_TYPE="patch" # Dummy value for increment arg
            fi

            echo "üîç Manual dispatch detected"
            echo "  INPUT_ADDON: '$INPUT_ADDON'"
            echo "  INPUT_VERSION: '$INPUT_VERSION'"

            if [ "$INPUT_ADDON" == "all" ]; then
              IS_ALL="true"
              # Find all add-ons (matching Python script logic)
              echo "üîç Finding all add-ons..."
              SKIP_ADDONS="homeassistant-test-instance"

              # Regular addons (top-level directories with config.yaml)
              # NOTE: .unsupported addons are excluded - they are built locally from unsupported branch
              for item in */; do
                item_name="${item%/}"
                if [ -f "${item}config.yaml" ] && [ ! "${item_name#.}" != "$item_name" ] && [ ! "${item_name#_}" != "$item_name" ]; then
                  # Skip test add-ons
                  skip=false
                  for skip_item in $SKIP_ADDONS; do
                    if [ "$item_name" == "$skip_item" ]; then
                      skip=true
                      break
                    fi
                  done
                  if [ "$skip" == "false" ]; then
                    [ -z "$ADDONS" ] && ADDONS="$item_name" || ADDONS="$ADDONS,$item_name"
                  fi
                fi
              done

              # .unsupported addons are NOT included - they are built locally from unsupported branch
              echo "‚ÑπÔ∏è Skipping .unsupported addons (built locally from unsupported branch)"

              SHOULD_RELEASE="true"
              echo "üì¶ Found add-ons: $ADDONS"
              echo "Count: $(echo "$ADDONS" | tr ',' '\n' | wc -l)"
            elif [ -n "$INPUT_ADDON" ] && [ "$INPUT_ADDON" != "detect" ]; then
              IS_ALL="false"
              # Handle comma-separated list
              IFS=',' read -ra INPUT_ADDONS_ARRAY <<< "$INPUT_ADDON"
              VALID_ADDONS=""

              for addon in "${INPUT_ADDONS_ARRAY[@]}"; do
                  addon=$(echo "$addon" | xargs) # trim whitespace

                  # Check if it exists (basic check, though dynamic check happens later too)
                  if [ ! -d "$addon" ]; then
                      echo "‚ö†Ô∏è Warning: Add-on directory '$addon' does not exist. Skipping."
                      continue
                  fi

                  # Check unsupported
                  if [[ "$addon" == .unsupported/* ]] || [[ "$addon" == .unsupported* ]]; then
                    echo "‚ùå Error: .unsupported addons cannot be built via this workflow"
                    echo "   .unsupported addons are built locally from the unsupported branch"
                    echo "   Skipping $addon"
                    continue
                  fi

                  [ -z "$VALID_ADDONS" ] && VALID_ADDONS="$addon" || VALID_ADDONS="$VALID_ADDONS,$addon"
              done

              if [ -n "$VALID_ADDONS" ]; then
                  ADDONS="$VALID_ADDONS"
                  SHOULD_RELEASE="true"
                  echo "üì¶ Add-ons to release: $ADDONS"
              else
                  echo "‚ùå No valid add-ons found to release from input: '$INPUT_ADDON'"
                  SHOULD_RELEASE="false"
              fi
            elif [ "$INPUT_ADDON" == "detect" ]; then
              IS_ALL="false"
              echo "üîç Auto-detection triggered manually (checking HEAD^ vs HEAD)"

              # Get list of changed files
              CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)

              for file in $CHANGED_FILES; do
                # Skip .unsupported addons
                if [[ "$file" == .unsupported/* ]]; then
                  echo "‚è≠Ô∏è Skipping .unsupported addon: $file (built locally from unsupported branch)"
                  continue
                fi

                if [[ "$file" == *"/config.yaml" ]]; then
                  addon_dir=$(dirname "$file")
                  addon_name=$(basename "$addon_dir")

                  # Check if version changed
                  # Get old version (handle new file case)
                  if git rev-parse --verify HEAD^:"$file" >/dev/null 2>&1; then
                      OLD_VERSION=$(git show HEAD^:"$file" | grep "^version:" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")
                  else
                      OLD_VERSION=""
                      echo "  ‚ÑπÔ∏è New file detected (no old version)"
                  fi
                  # Get new version
                  NEW_VERSION=$(grep "^version:" "$file" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")

                  if [ "$OLD_VERSION" != "$NEW_VERSION" ] && [ -n "$NEW_VERSION" ]; then
                     echo "üöÄ Detected version bump in $addon_name: $OLD_VERSION -> $NEW_VERSION"
                     [ -z "$ADDONS" ] && ADDONS="$addon_name" || ADDONS="$ADDONS,$addon_name"
                     SHOULD_RELEASE="true"
                     IS_MANUAL_BUMP="true"
                     SHOULD_RELEASE="true"
                     IS_MANUAL_BUMP="true"
                     TARGET_VERSION="$NEW_VERSION"
                     VERSION_TYPE="patch" # Dummy value
                  fi
                fi
              done

              if [ -z "$ADDONS" ]; then
                echo "‚ÑπÔ∏è No version bumps detected in last commit."
              fi
            else
              IS_ALL="false"
              echo "‚ö†Ô∏è Invalid or missing addon input: '$INPUT_ADDON'"
              SHOULD_RELEASE="false"
            fi

          # ----------------------------------------------------------------
          # REPOSITORY DISPATCH
          # ----------------------------------------------------------------
          elif [ "$EVENT_NAME" == "repository_dispatch" ]; then
            IS_AUTO="true"
            VERSION_TYPE="${DISPATCH_VERSION:-patch}"

            if [ -n "$DISPATCH_ADDON" ]; then
              ADDONS="$DISPATCH_ADDON"
              SHOULD_RELEASE="true"
            fi

          # ----------------------------------------------------------------
          # MERGED PR (Auto-release)
          # ----------------------------------------------------------------
          elif [ "$EVENT_NAME" == "pull_request" ]; then
            IS_AUTO="true"

            # Check if PR was merged
            if [ "$PR_MERGED" != "true" ]; then
              echo "PR was not merged, skipping."
              {
                echo "should_release=false"
                echo "addons=[]"
                echo "is_auto=false"
                echo "version_type=patch"
              } >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Check for blocking labels
            CLEAN_BLOCK_LABELS=$(echo "$BLOCK_LABELS" | tr '\n' ' ')
            for label in $CLEAN_BLOCK_LABELS; do
              if echo "$PR_LABELS" | grep -qi "\"$label\""; then
                echo "‚õî Found blocking label: $label"
                {
                  echo "should_release=false"
                  echo "addons=[]"
                  echo "is_auto=true"
                  echo "version_type=patch"
                } >> "$GITHUB_OUTPUT"
                exit 0
              fi
            done

            # Get PR Title for safe check
            PR_TITLE=$(gh pr view "$PR_NUMBER" --json title --jq '.title' || echo "")

            # Check for safe labels
            HAS_SAFE="false"
            CLEAN_SAFE_LABELS=$(echo "$SAFE_LABELS" | tr '\n' ' ')
            for label in $CLEAN_SAFE_LABELS; do
              if echo "$PR_LABELS" | grep -qi "\"$label\""; then
                HAS_SAFE="true"
                break
              fi
            done

            if [ "$HAS_SAFE" != "true" ]; then
              # Check PR Title for safe patterns (Renovate)
              echo "DEBUG: Checking PR Title: '$PR_TITLE'"
              REGEX_DEP="^‚¨ÜÔ∏è Update dependency"
              REGEX_TAG="^‚¨ÜÔ∏è Update .* Docker tag"

              if [[ "$PR_TITLE" =~ $REGEX_DEP ]] || [[ "$PR_TITLE" =~ $REGEX_TAG ]]; then
                echo "‚úÖ Safe PR Title detected (Renovate): $PR_TITLE"
                HAS_SAFE="true"
              else
                echo "No safe labels or safe title patterns found"
                {
                  echo "should_release=false"
                  echo "addons=[]"
                  echo "is_auto=true"
                  echo "is_auto=true"
                  echo "version_type=patch"
                  echo "target_version="
                } >> "$GITHUB_OUTPUT"
                exit 0
              fi
            fi

            # Get changed files using PR API as primary source
            echo "üîç Fetching changed files via GitHub API..."
            if CHANGED=$(gh pr view "$PR_NUMBER" --json files --jq '.files[].path' 2>/dev/null); then
              echo "‚úÖ Successfully fetched changed files from PR API"
            else
              echo "‚ö†Ô∏è Failed to fetch changed files from PR API (Branch might be deleted). Using git diff fallback..."
              # HEAD is the merge commit. HEAD^ is the state before the PR merge.
              CHANGED=$(git diff --name-only HEAD^ HEAD)
            fi

            if [ -z "$CHANGED" ]; then
              echo "‚ùå Error: Could not detect any changed files for verification."
              {
                echo "should_release=false"
                echo "addons=[]"
                echo "is_auto=true"
                echo "version_type=patch"
              } >> "$GITHUB_OUTPUT"
              exit 0
            fi

            # Check if this is a base image update by checking PR title/description
            IS_BASE_IMAGE_UPDATE="false"
            # PR_TITLE is already fetched above
            PR_BODY=$(gh pr view "$PR_NUMBER" --json body --jq '.body' || echo "")
            if echo "$PR_TITLE $PR_BODY" | grep -qiE "(base.*image|hassio-addons/(base|debian-base|base-python)|Add-on base images|Bailys|Homeassistant Addon Base|Important Update)"; then
              IS_BASE_IMAGE_UPDATE="true"
              echo "üîç Base image update detected from PR title/description"
            fi

            # ----------------------------------------------------------------
            # Identify affected addons
            # ----------------------------------------------------------------
            # If base image update, release ALL affected addons (not just AUTO_RELEASE_ADDONS)
            # NOTE: .unsupported addons are excluded - they are built locally from unsupported branch
            if [ "$IS_BASE_IMAGE_UPDATE" == "true" ]; then
              echo "üîç Base image update - releasing all affected addons (excluding .unsupported)"
              # Find all addons with changed Dockerfile or build.yaml
              for file in $CHANGED; do
                # Skip .unsupported addons - they are built locally from unsupported branch
                if [[ "$file" =~ ^\.unsupported/ ]]; then
                  echo "  ‚è≠Ô∏è Skipping .unsupported addon: $file"
                  continue
                fi

                # Extract addon directory from file path (only regular addons)
                if [[ "$file" =~ ^([^/]+)/ ]]; then
                  addon_dir="${BASH_REMATCH[1]}"
                else
                  continue
                fi

                # Check if Dockerfile or build.yaml in this addon was changed
                if echo "$CHANGED" | grep -qE "^${addon_dir}/(Dockerfile|build\.yaml)$"; then
                  # Skip if already added
                  if [[ ! ",$ADDONS," =~ ,"$addon_dir", ]]; then
                    [ -z "$ADDONS" ] && ADDONS="$addon_dir" || ADDONS="$ADDONS,$addon_dir"
                    echo "  ‚úÖ Added $addon_dir (Dockerfile/build.yaml changed)"
                  fi
                fi
              done
            else
              # ----------------------------------------------------------------
              # Detect NEW Add-ons (config.yaml added)
              # ----------------------------------------------------------------
              echo "üîç Checking for newly or modified add-ons..."
              CLEAN_IGNORE_ADDONS="$(echo "$AUTO_RELEASE_IGNORE" | tr '\n' ' ')"

              # Loop through changed files to detect affected addons
              for file in $CHANGED; do
                 # Skip .unsupported (already handled at top level, but for safety in loop)
                 if [[ "$file" == .unsupported/* ]]; then
                    continue
                 fi

                 # Extract addon slug (first directory level)
                 if [[ "$file" =~ ^([^/]+)/ ]]; then
                    addon_dir="${BASH_REMATCH[1]}"

                    # Skip hidden directories (like .github, .scripts), internal folders (_images), or docs
                    if [[ "$addon_dir" == .* ]] || [[ "$addon_dir" == _* ]] || [[ "$addon_dir" == "docs" ]]; then
                       continue
                    fi

                    # Skip if already identified as target
                    if [[ ",$ADDONS," =~ ,"$addon_dir", ]]; then
                       continue
                    fi

                    # IMPORTANT: Verify it's actually an add-on directory by checking for config.yaml
                    if [ ! -f "${addon_dir}/config.yaml" ]; then
                       continue
                    fi

                    # 1. Detect NEW addons (config.yaml added)
                    if [[ "$file" == "${addon_dir}/config.yaml" ]] && git diff --name-status HEAD^ HEAD | grep -qE "^A.*${file}"; then
                        echo "  üöÄ Detected NEW add-on: $addon_dir"
                        [ -z "$ADDONS" ] && ADDONS="$addon_dir" || ADDONS="$ADDONS,$addon_dir"
                        continue
                    fi

                    # 2. Detect updates for ALL addons (except ignored)
                    if [[ " $CLEAN_IGNORE_ADDONS " != *" $addon_dir "* ]]; then
                       echo "  ‚úÖ Added $addon_dir (Changed file: $file)"
                       [ -z "$ADDONS" ] && ADDONS="$addon_dir" || ADDONS="$ADDONS,$addon_dir"
                    else
                       echo "  ‚è≠Ô∏è Skipping ignored addon: $addon_dir"
                    fi
                 fi
              done
            fi

            # ----------------------------------------------------------------
            # Check for Manual Version Bumps in PR (Manifest Version Change)
            # ----------------------------------------------------------------
            echo "üîç Checking for explicit version bumps in config.yaml..."
            # Check for version changes in any config.yaml
            for file in $CHANGED; do
              if [[ "$file" == *"/config.yaml" ]]; then
                addon_dir=$(dirname "$file")
                addon_slug=$(basename "$addon_dir")

                # Skip .unsupported
                if [[ "$addon_dir" == .unsupported/* ]]; then continue; fi

                # Check if version field actually changed
                if git rev-parse --verify HEAD^:"$file" >/dev/null 2>&1; then
                    OLD_VERSION=$(git show HEAD^:"$file" | grep "^version:" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")
                else
                    OLD_VERSION=""
                fi
                NEW_VERSION=$(grep "^version:" "$file" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")

                if [ "$OLD_VERSION" != "$NEW_VERSION" ] && [ -n "$NEW_VERSION" ]; then
                   echo "üöÄ Detected explicit version bump in $addon_slug: $OLD_VERSION -> $NEW_VERSION"
                   # Add to ADDONS if not already there
                   if [[ ! ",$ADDONS," =~ ,"$addon_slug", ]]; then
                     [ -z "$ADDONS" ] && ADDONS="$addon_slug" || ADDONS="$ADDONS,$addon_slug"
                   fi
                   # Use this version instead of patch bump
                   TARGET_VERSION="$NEW_VERSION"
                   VERSION_TYPE="patch" # Dummy value
                   IS_MANUAL_BUMP="true"
                fi
              fi
            done

            [ -n "$ADDONS" ] && SHOULD_RELEASE="true"
          # ----------------------------------------------------------------
          # PUSH TO MASTER (Manual Version Bump Detection or release(all) trigger)
          # ----------------------------------------------------------------
          elif [ "$EVENT_NAME" == "push" ]; then
             IS_AUTO="false"

             # Check for "release(all)" in commit message
             COMMIT_MSG="$HEAD_COMMIT_MSG"
             if echo "$COMMIT_MSG" | grep -qi "release(all)"; then
               echo "üöÄ Detected 'release(all)' in commit message - releasing all add-ons"
               SKIP_ADDONS="homeassistant-test-instance sap-abap-cloud-dev"

               # Regular addons (top-level directories with config.yaml)
               # NOTE: .unsupported addons are excluded - they are built locally from unsupported branch
               for item in */; do
                 item_name="${item%/}"
                 if [ -f "${item}config.yaml" ] && [ ! "${item_name#.}" != "$item_name" ] && [ ! "${item_name#_}" != "$item_name" ]; then
                   # Skip test add-ons
                   skip=false
                   for skip_item in $SKIP_ADDONS; do
                     if [ "$item_name" == "$skip_item" ]; then
                       skip=true
                       break
                     fi
                   done
                   if [ "$skip" == "false" ]; then
                     [ -z "$ADDONS" ] && ADDONS="$item_name" || ADDONS="$ADDONS,$item_name"
                   fi
                 fi
               done

               # .unsupported addons are NOT included - they are built locally from unsupported branch
               echo "‚ÑπÔ∏è Skipping .unsupported addons (built locally from unsupported branch)"

               SHOULD_RELEASE="true"
               VERSION_TYPE="patch" # Default for release(all)
               echo "üì¶ Found add-ons: $ADDONS"
             else
               IS_ALL="false"
               # Original logic: Detect manual version bumps
               # NOTE: .unsupported addons are excluded - they are built locally from unsupported branch
               # Get list of changed files
               CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)

               for file in $CHANGED_FILES; do
                 # Skip .unsupported addons - they are built locally from unsupported branch
                 if [[ "$file" == .unsupported/* ]]; then
                   echo "‚è≠Ô∏è Skipping .unsupported addon: $file (built locally from unsupported branch)"
                   continue
                 fi

                 if [[ "$file" == *"/config.yaml" ]]; then
                   addon_dir=$(dirname "$file")
                   addon_name=$(basename "$addon_dir")

                   # Check if version changed
                   # Get old version (handle new file case)
                   if git rev-parse --verify HEAD^:"$file" >/dev/null 2>&1; then
                       OLD_VERSION=$(git show HEAD^:"$file" | grep "^version:" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")
                   else
                       OLD_VERSION=""
                       echo "  ‚ÑπÔ∏è New file detected (no old version)"
                   fi
                   # Get new version
                   NEW_VERSION=$(grep "^version:" "$file" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")

                   if [ "$OLD_VERSION" != "$NEW_VERSION" ] && [ -n "$NEW_VERSION" ]; then
                      echo "üöÄ Detected version bump in $addon_name: $OLD_VERSION -> $NEW_VERSION"
                      [ -z "$ADDONS" ] && ADDONS="$addon_name" || ADDONS="$ADDONS,$addon_name"
                      SHOULD_RELEASE="true"
                      IS_MANUAL_BUMP="true"
                      TARGET_VERSION="$NEW_VERSION"
                      VERSION_TYPE="patch" # Dummy value
                   fi
                 fi
               done
             fi

          fi

          # Sort addons by priority (only if multiple addons are affected)
          if [ -n "$ADDONS" ]; then
            ADDON_COUNT=$(echo "$ADDONS" | tr ',' '\n' | wc -l | tr -d ' ')
            if [ "$ADDON_COUNT" -gt 1 ]; then
              echo "üìã Sorting addons by priority (multiple addons detected)..."

              # Split into categories
              NORMAL_ADDONS=""
              SWITCH_LAN_PLAY_ADDONS=""
              PTERODACTYL_WINGS_ADDONS=""
              PTERODACTYL_PANEL_ADDONS=""
              ANTIGRAVITY_ADDON=""
              SAP_ADDON=""
              UNSUPPORTED_ADDONS=""

              # Process each addon
              IFS=','
              for addon in $ADDONS; do
                addon=$(echo "$addon" | xargs)  # trim whitespace

              # Check category
              if [[ "$addon" == .unsupported/* ]]; then
                # Unsupported addons go last
                [ -z "$UNSUPPORTED_ADDONS" ] && UNSUPPORTED_ADDONS="$addon" || UNSUPPORTED_ADDONS="$UNSUPPORTED_ADDONS,$addon"
              elif [[ "$addon" == "sap-abap-cloud-dev" ]]; then
                 # SAP goes second-to-last (after antigravity, before unsupported)
                SAP_ADDON="$addon"
              elif [[ "$addon" == "antigravity-server" ]]; then
                # antigravity-server goes third-to-last
                ANTIGRAVITY_ADDON="$addon"
              elif [[ "$addon" == pterodactyl-panel* ]]; then
                 # pterodactyl panel goes fourth-to-last
                 [ -z "$PTERODACTYL_PANEL_ADDONS" ] && PTERODACTYL_PANEL_ADDONS="$addon" || PTERODACTYL_PANEL_ADDONS="$PTERODACTYL_PANEL_ADDONS,$addon"
              elif [[ "$addon" == pterodactyl-wings* ]]; then
                 # pterodactyl wings goes fifth-to-last
                 [ -z "$PTERODACTYL_WINGS_ADDONS" ] && PTERODACTYL_WINGS_ADDONS="$addon" || PTERODACTYL_WINGS_ADDONS="$PTERODACTYL_WINGS_ADDONS,$addon"
              elif [[ "$addon" == switch_lan_play* ]]; then
                # switch_lan_play addons go sixth-to-last
                [ -z "$SWITCH_LAN_PLAY_ADDONS" ] && SWITCH_LAN_PLAY_ADDONS="$addon" || SWITCH_LAN_PLAY_ADDONS="$SWITCH_LAN_PLAY_ADDONS,$addon"
              else
                # Normal addons go first
                [ -z "$NORMAL_ADDONS" ] && NORMAL_ADDONS="$addon" || NORMAL_ADDONS="$NORMAL_ADDONS,$addon"
              fi
            done
            unset IFS

            # Rebuild in correct order
            SORTED_ADDONS=""
            [ -n "$NORMAL_ADDONS" ] && SORTED_ADDONS="$NORMAL_ADDONS"
            [ -n "$SWITCH_LAN_PLAY_ADDONS" ] && {
              [ -n "$SORTED_ADDONS" ] && SORTED_ADDONS="$SORTED_ADDONS,$SWITCH_LAN_PLAY_ADDONS" || SORTED_ADDONS="$SWITCH_LAN_PLAY_ADDONS"
            }
            [ -n "$PTERODACTYL_WINGS_ADDONS" ] && {
                [ -n "$SORTED_ADDONS" ] && SORTED_ADDONS="$SORTED_ADDONS,$PTERODACTYL_WINGS_ADDONS" || SORTED_ADDONS="$PTERODACTYL_WINGS_ADDONS"
            }
            [ -n "$PTERODACTYL_PANEL_ADDONS" ] && {
                [ -n "$SORTED_ADDONS" ] && SORTED_ADDONS="$SORTED_ADDONS,$PTERODACTYL_PANEL_ADDONS" || SORTED_ADDONS="$PTERODACTYL_PANEL_ADDONS"
            }
            [ -n "$ANTIGRAVITY_ADDON" ] && {
              [ -n "$SORTED_ADDONS" ] && SORTED_ADDONS="$SORTED_ADDONS,$ANTIGRAVITY_ADDON" || SORTED_ADDONS="$ANTIGRAVITY_ADDON"
            }
            [ -n "$SAP_ADDON" ] && {
              [ -n "$SORTED_ADDONS" ] && SORTED_ADDONS="$SORTED_ADDONS,$SAP_ADDON" || SORTED_ADDONS="$SAP_ADDON"
            }
            [ -n "$UNSUPPORTED_ADDONS" ] && {
              [ -n "$SORTED_ADDONS" ] && SORTED_ADDONS="$SORTED_ADDONS,$UNSUPPORTED_ADDONS" || SORTED_ADDONS="$UNSUPPORTED_ADDONS"
            }

            ADDONS="$SORTED_ADDONS"
            echo "‚úÖ Sorted addons: $ADDONS"
            fi
          fi

          # Convert to JSON array (compact format for GitHub Actions output)
          if [ -n "$ADDONS" ]; then
            JSON="$(echo "$ADDONS" | tr ',' '\n' | jq -R . | jq -s -c .)"
          else
            JSON="[]"
          fi

          echo "Addons: $ADDONS"
          echo "Should release: $SHOULD_RELEASE"
          echo "Is auto: $IS_AUTO"
          echo "Version type: $VERSION_TYPE"
          echo "Is manual bump: ${IS_MANUAL_BUMP:-false}"
          echo "Is all: ${IS_ALL:-false}"

          # Output as compact JSON (single line) to avoid formatting issues
          # shellcheck disable=SC2129
          printf "addons=%s\n" "$JSON" >> "$GITHUB_OUTPUT"
          printf "should_release=%s\n" "$SHOULD_RELEASE" >> "$GITHUB_OUTPUT"
          printf "is_auto=%s\n" "$IS_AUTO" >> "$GITHUB_OUTPUT"
          printf "version_type=%s\n" "$VERSION_TYPE" >> "$GITHUB_OUTPUT"
          # shellcheck disable=SC2154
          printf "target_version=%s\n" "$TARGET_VERSION" >> "$GITHUB_OUTPUT"
          # shellcheck disable=SC2154
          printf "is_manual_bump=%s\n" "${IS_MANUAL_BUMP:-false}" >> "$GITHUB_OUTPUT"
          printf "is_all=%s\n" "${IS_ALL:-false}" >> "$GITHUB_OUTPUT"

  # ================================================================================
  # VERIFY: Lint and test build before release
  # ================================================================================
  verify:
    name: ‚úÖ Verify ${{ matrix.addon }}
    needs: detect
    if: needs.detect.outputs.should_release == 'true' && github.event.inputs.skip_verification != 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        addon: ${{ fromJson(needs.detect.outputs.addons) }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v6

      - name: üïµÔ∏è Add-on Linter
        uses: frenck/action-addon-linter@v2
        with:
          path: "./${{ matrix.addon }}"

      - name: ‚ÑπÔ∏è Get Add-on Info
        id: info
        uses: home-assistant/actions/helpers/info@master
        with:
          path: "./${{ matrix.addon }}"

      - name: üîß Inject Version Warning
        run: |
          pip install pyyaml --quiet
          python3 .scripts/inject_version_warning.py "${{ matrix.addon }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üèóÔ∏è Test Build
        if: matrix.addon != 'sap-abap-cloud-dev'
        uses: home-assistant/builder@2025.11.0
        with:
          args: |
            --test \
            --amd64 \
            --target /data/${{ matrix.addon }} \
            --image "${{ steps.info.outputs.image }}" \
            --docker-hub "ghcr.io/${{ github.repository_owner }}" \
            --addon

  # ================================================================================
  # RELEASE: Build & Push
  # ================================================================================
  release:
    name: üöÄ Release ${{ matrix.addon }}
    needs: [detect, verify]
    if: |
      always() &&
      needs.detect.outputs.should_release == 'true' &&
      (needs.verify.result == 'success' || needs.verify.result == 'skipped' || github.event.inputs.skip_verification == 'true')
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      # Use max-parallel: 5 to allow concurrent releases
      # Retry logic handles potential git race conditions
      max-parallel: 5
      matrix:
        addon: ${{ fromJson(needs.detect.outputs.addons) }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v6
        with:
          token: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üè∑Ô∏è Detect if unsupported
        id: status
        run: |
          # shellcheck disable=SC2193
          if [[ "${{ matrix.addon }}" == .unsupported/* ]]; then
            echo "is_unsupported=true" >> "$GITHUB_OUTPUT"
            echo "üì¶ Addon is UNSUPPORTED"
          else
            echo "is_unsupported=false" >> "$GITHUB_OUTPUT"
          fi

      - name: üîß Inject Version Warning
        run: |
          pip install pyyaml --quiet
          python3 .scripts/inject_version_warning.py "${{ matrix.addon }}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üîß Fix Image Field Format (if needed)
        if: matrix.addon != 'sap-abap-cloud-dev'
        run: |
          # Ensure image field uses correct format: ghcr.io/faserf/hassio-addons-{slug}-{arch}
          SLUG=$(grep "^slug:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")
          CORRECT_IMAGE="ghcr.io/faserf/hassio-addons-${SLUG}-{arch}"

          if grep -q "^image:" "${{ matrix.addon }}/config.yaml"; then
            CURRENT_IMAGE=$(grep "^image:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")
            if [ "$CURRENT_IMAGE" != "$CORRECT_IMAGE" ]; then
              sed -i "s|^image:.*|image: ${CORRECT_IMAGE}|g" "${{ matrix.addon }}/config.yaml"
              echo "‚úÖ Updated image field from '$CURRENT_IMAGE' to '$CORRECT_IMAGE'"
            else
              echo "‚ÑπÔ∏è Image field already correct: $CORRECT_IMAGE"
            fi
          else
            # Add image field if missing
            sed -i "/^slug:.*/a image: ${CORRECT_IMAGE}" "${{ matrix.addon }}/config.yaml"
            echo "‚úÖ Added image field: $CORRECT_IMAGE"
          fi

      - name: ‚ÑπÔ∏è Get Add-on Info
        id: info
        uses: home-assistant/actions/helpers/info@master
        with:
          path: "./${{ matrix.addon }}"

      - name: üêã Login to GitHub Container Registry
        if: matrix.addon != 'sap-abap-cloud-dev'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: üê≥ Set up Docker Buildx
        if: matrix.addon != 'sap-abap-cloud-dev'
        uses: docker/setup-buildx-action@v3

      - name: üíæ Cache Docker layers (optimized for shared base image)
        uses: actions/cache@v5
        with:
          path: /tmp/.buildx-cache-${{ matrix.addon }}
          # Primary key: addon-specific for precise cache hits
          key: ${{ runner.os }}-buildx-${{ matrix.addon }}-${{ github.sha }}
          restore-keys: |
            # Try addon-specific cache first
            ${{ runner.os }}-buildx-${{ matrix.addon }}-
            # Fallback to shared base image cache (all addons share base:19.0.0)
            ${{ runner.os }}-buildx-base-image-19.0.0-
            # Last resort: any buildx cache
            ${{ runner.os }}-buildx-

      - name: üìù Bump Version & Changelog
        run: |
          VERSION_TYPE="${{ needs.detect.outputs.version_type }}"
          TARGET_VERSION="${{ needs.detect.outputs.target_version }}"
          IS_AUTO="${{ needs.detect.outputs.is_auto }}"
          IS_MANUAL_BUMP="${{ needs.detect.outputs.is_manual_bump }}"
          CHANGELOG_ONLY="${{ github.event.inputs.changelog_only || 'false' }}"

          if [ "$IS_AUTO" == "true" ]; then
            MSG="Automatic release after dependency update"
          else
            # Use custom message if provided, otherwise default
            if [ -n "${{ github.event.inputs.changelog_message }}" ]; then
              MSG="${{ github.event.inputs.changelog_message }}"
            else
              MSG="Manual release via Orchestrator"
            fi
          fi

          if [ "$IS_MANUAL_BUMP" == "true" ] || [ "$CHANGELOG_ONLY" == "true" ]; then
             echo "‚ÑπÔ∏è Changelog-only mode: Updating Changelog without version bump."
             # Get current version from config.yaml
             CURRENT_VERSION=$(grep "^version:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")
             python3 .scripts/bump_version.py "${{ matrix.addon }}" patch --target-version "$CURRENT_VERSION" --changelog-only --message "$MSG"
          else
             PYTHON_CMD="python3 .scripts/bump_version.py \"${{ matrix.addon }}\" \"$VERSION_TYPE\" --message \"$MSG\""

             if [ -n "$TARGET_VERSION" ] && [ "$TARGET_VERSION" != "null" ]; then
                PYTHON_CMD="python3 .scripts/bump_version.py \"${{ matrix.addon }}\" patch --target-version \"$TARGET_VERSION\" --message \"$MSG\""
             fi

             eval "$PYTHON_CMD"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: üîç Debug Git Status (Post-Bump)
        run: |
          echo "Current directory: $(pwd)"
          ls -la "${{ matrix.addon }}"
          git status
          git diff
          grep "version:" "${{ matrix.addon }}/config.yaml"

      - name: üîÑ Pull latest changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Store local changes for this addon
          ADDON_FILES="."
          if [ -n "$(git status --porcelain)" ]; then
            echo "üì¶ Stashing local changes for ${{ matrix.addon }}..."
            git stash push -u -m "temp-stash-${{ matrix.addon }}" || echo "No changes to stash"
          fi

          # Fetch and update to latest master
          git fetch origin master
          git reset --hard origin/master

          # Restore and reapply local changes
          if git stash list | grep -q "temp-stash-${{ matrix.addon }}"; then
            STASH_ENTRY=$(git stash list | grep "temp-stash-${{ matrix.addon }}" | head -n1 | cut -d: -f1)
            if [ -n "$STASH_ENTRY" ]; then
              # Apply stash (don't pop, in case of conflicts)
              git stash apply "$STASH_ENTRY" || {
                echo "‚ö†Ô∏è Merge conflict detected, resolving..."
                # If there's a conflict, resolve by taking our version (the addon files)
                git checkout --ours -- "$ADDON_FILES" 2>/dev/null || true
                git add "$ADDON_FILES"
                # Clean up the stash
                git stash drop "$STASH_ENTRY" 2>/dev/null || true
              }
            fi
          fi

          # Ensure we're on the latest master (handle any merge state)
          git merge --abort 2>/dev/null || true
          git rebase --abort 2>/dev/null || true
          git rebase --abort 2>/dev/null || true

          # Reapply changes one more time if needed
          if [ -n "$(git status --porcelain "$ADDON_FILES")" ]; then
            echo "‚úÖ Local changes preserved for ${{ matrix.addon }}"
          fi

      - name: üöÄ Commit & Push (with Retry)
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          MAX_RETRIES=5

          for ((i=1; i<=MAX_RETRIES; i++)); do
            echo "Attempt $i of $MAX_RETRIES..."

            # 1. Check status and Commit
            if [ -n "$(git status --porcelain "${{ matrix.addon }}")" ]; then
              git add "${{ matrix.addon }}"
              COMMIT_MSG="${{ github.event.inputs.changelog_only == 'true' && format('üìù release({0}): update changelog [skip-tests]', matrix.addon) || format('üöÄ release({0}): version bump [skip-tests]', matrix.addon) }}"
              git commit -m "$COMMIT_MSG" --author="FaserF <12374134+FaserF@users.noreply.github.com>" || echo "Commit failed or empty"
            else
              echo "Nothing to commit (or already committed)"
            fi

            # 2. Push
            if git push origin master; then
              echo "‚úÖ Push successful!"
              exit 0
            fi

            echo "‚ö†Ô∏è Push failed."
            if [ $i -lt $MAX_RETRIES ]; then
              # Random jitter (5-14 seconds)
              JITTER=$(( ( RANDOM % 10 )  + 5 ))
              echo "Waiting ${JITTER}s before retry..."
              sleep $JITTER

              echo "üîÑ Pulling latest changes (rebase)..."
              git pull --rebase origin master || {
                echo "Rebase failed, trying merge..."
                git rebase --abort 2>/dev/null || true
                git pull origin master --no-rebase || echo "Merge failed"
              }
            fi
          done
          echo "‚ùå Failed to push after $MAX_RETRIES attempts"
          exit 1

      - name: ‚ÑπÔ∏è Get Add-on Info (Post-Bump)
        id: info_build
        uses: home-assistant/actions/helpers/info@master
        with:
          path: "./${{ matrix.addon }}"

      - name: üóëÔ∏è Delete existing image version (if exists)
        continue-on-error: true
        run: |
          # Extract version from config.yaml
          VERSION=$(grep "^version:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'")

          # Get package name from config.yaml image field
          # Format: ghcr.io/faserf/hassio-addons-{slug}-{arch}
          IMAGE_FROM_CONFIG=$(grep "^image:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'" || echo "")

          if [ -z "$IMAGE_FROM_CONFIG" ]; then
            # Fallback: use slug
            SLUG=$(grep "^slug:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'" || echo "")
            PACKAGE_NAME="hassio-addons-${SLUG}"
          else
            # Extract package name: remove ghcr.io/faserf/ prefix
            PACKAGE_NAME=$(echo "$IMAGE_FROM_CONFIG" | sed 's|ghcr.io/faserf/||' | sed 's/-{arch}$//' | sed 's/-amd64$//' | sed 's/-aarch64$//' | sed 's/-armhf$//' | sed 's/-armv7$//' | sed 's/-i386$//')
          fi

          OWNER="${{ github.repository_owner }}"

          echo "üîç Checking for existing image: $PACKAGE_NAME:$VERSION"

          # Get GitHub API token
          TOKEN="${{ secrets.GITHUB_TOKEN }}"

          # Function to delete version from a package
          delete_version() {
            local pkg_name=$1
            local version=$2
            local base_url=$3

            RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: Bearer ${TOKEN}" -H "Accept: application/vnd.github.v3+json" "$base_url")
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            VERSIONS_JSON=$(echo "$RESPONSE" | sed '$d')

            if [ "$HTTP_CODE" = "200" ]; then
              # Find version ID for the specific version tag
              VERSION_ID=$(echo "$VERSIONS_JSON" | jq -r ".[] | select(.metadata.container.tags[]? == \"$version\") | .id" | head -n1)

              if [ -n "$VERSION_ID" ] && [ "$VERSION_ID" != "null" ]; then
                echo "üóëÔ∏è Found existing version $version (ID: $VERSION_ID) for $pkg_name, deleting..."
                DELETE_URL="${base_url}/${VERSION_ID}"
                DELETE_RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE -H "Authorization: Bearer ${TOKEN}" -H "Accept: application/vnd.github.v3+json" "$DELETE_URL")
                DELETE_CODE=$(echo "$DELETE_RESPONSE" | tail -n1)

                if [ "$DELETE_CODE" = "204" ]; then
                  echo "‚úÖ Successfully deleted existing version $version for $pkg_name"
                  return 0
                else
                  echo "‚ö†Ô∏è Failed to delete version (HTTP $DELETE_CODE)"
                  return 1
                fi
              fi
            fi
            return 1
          }

          # Try org endpoint first, then user endpoint
          ORG_URL="https://api.github.com/orgs/${OWNER}/packages/container/${PACKAGE_NAME}/versions"
          USER_URL="https://api.github.com/users/${OWNER}/packages/container/${PACKAGE_NAME}/versions"

          if ! delete_version "$PACKAGE_NAME" "$VERSION" "$ORG_URL"; then
            if ! delete_version "$PACKAGE_NAME" "$VERSION" "$USER_URL"; then
              echo "‚ÑπÔ∏è No existing version $VERSION found for $PACKAGE_NAME, proceeding with build"
            fi
          fi

      - name: üèóÔ∏è Build & Push Add-on
        if: matrix.addon != 'sap-abap-cloud-dev'
        run: |
          # Read architectures from config.yaml
          # shellcheck disable=SC2001,SC2046
          ARCHS=$(grep -A 10 "^arch:" "${{ matrix.addon }}/config.yaml" | grep -E "^\s+-" | sed 's/^\s*-\s*//' | tr '\n' ' ' | xargs || echo "")

          # Default to amd64 and aarch64 if no arches found
          if [ -z "$ARCHS" ]; then
            ARCHS="amd64 aarch64"
          fi

          echo "üîç Detected architectures: $ARCHS"

          # Build builder args based on supported architectures (only amd64 and aarch64)
          # Note: armhf, armv7, and i386 are not supported by this repo
          BUILDER_ARGS=""
          for arch in $ARCHS; do
            case "$arch" in
              amd64)
                BUILDER_ARGS="${BUILDER_ARGS}--amd64 \\\\n            "
                ;;
              aarch64)
                BUILDER_ARGS="${BUILDER_ARGS}--aarch64 \\\\n            "
                ;;
              armhf|armv7|i386)
                echo "‚ö†Ô∏è Skipping unsupported architecture: $arch"
                ;;
            esac
          done

          # Remove trailing backslash and newline
          BUILDER_ARGS=$(echo -e "$BUILDER_ARGS" | sed 's/\\\\n[[:space:]]*$//')

          # Ensure at least amd64 and aarch64 are built
          if [ -z "$BUILDER_ARGS" ]; then
            BUILDER_ARGS="--amd64 \\\\n            --aarch64"
            BUILDER_ARGS=$(echo -e "$BUILDER_ARGS" | sed 's/\\\\n[[:space:]]*$//')
          fi

          echo "üèóÔ∏è Building with args:"
          echo -e "$BUILDER_ARGS"

          # Extract image name from config.yaml
          # Format should be: ghcr.io/faserf/hassio-addons-{slug}-{arch}
          # Builder expects: hassio-addons-{slug}-{arch} (without registry prefix)
          IMAGE_FROM_CONFIG=$(grep "^image:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'" || echo "")

          if [ -z "$IMAGE_FROM_CONFIG" ]; then
            # Fallback: use slug from config
            SLUG=$(grep "^slug:" "${{ matrix.addon }}/config.yaml" | head -n 1 | awk '{print $2}' | tr -d '"' | tr -d "'" || echo "")
            IMAGE_NAME="hassio-addons-${SLUG}-{arch}"
          else
            # Remove ghcr.io/faserf/ prefix to get package name
            # shellcheck disable=SC2001
            IMAGE_NAME=$(echo "$IMAGE_FROM_CONFIG" | sed 's|ghcr.io/faserf/||')
          fi

          echo "üì¶ Using image name: $IMAGE_NAME"

          # Use docker run directly to have full control over args
          # Mount Docker config so builder can access GHCR credentials
          # Mount cache directory for faster builds (caching enabled, --no-cache removed)
          # Mount cache directory for faster builds (caching enabled, --no-cache removed)
          # Mount cache directory for faster builds (caching enabled, --no-cache removed)
          # shellcheck disable=SC2046,SC2001
          docker run --rm --privileged \
            -v /var/run/docker.sock:/var/run/docker.sock \
            -v "$HOME/.docker/config.json:/root/.docker/config.json:ro" \
            -v "$(pwd)":/data \
            -v /tmp/.buildx-cache-${{ matrix.addon }}:/cache:rw \
            ghcr.io/home-assistant/amd64-builder:2025.11.0 \
            $(echo -e "$BUILDER_ARGS") \
            --target "/data/${{ matrix.addon }}" \
            --image "$IMAGE_NAME" \
            --docker-hub "ghcr.io/${{ github.repository_owner }}" \
            --addon

      - name: üì¢ Release Summary
        run: |
          {
            echo "### üöÄ Release Complete"
            echo ""
            echo "**Add-on:** ${{ matrix.addon }}"
            echo "**Type:** ${{ needs.detect.outputs.is_auto == 'true' && 'Auto-release' || 'Manual release' }}"
            echo "**Unsupported:** ${{ steps.status.outputs.is_unsupported }}"
            echo "**Time:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          } >> "$GITHUB_STEP_SUMMARY"

  # ================================================================================
  # MONITOR: Check for failure threshold (3 failures) and cancel remaining jobs
  # ================================================================================
  monitor-failures:
    name: ‚ö†Ô∏è Monitor Release Failures
    needs: [detect]
    if: |
      needs.detect.outputs.is_all == 'true' &&
      needs.detect.outputs.should_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    steps:
      - name: üîç Monitor and Cancel on Threshold
        run: |
          echo "Starting failure monitor for 'all' release..."
          echo "Will cancel remaining jobs if 3 failures are detected."
          echo "Will also cancel remaining jobs after 5 successful skipped addons."
          echo ""

          MAX_FAILURES=3
          MAX_SKIPPED_SUCCESS=5
          CHECK_INTERVAL=30  # Check every 30 seconds
          MAX_WAIT_TIME=3600  # Maximum wait time: 1 hour
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT_TIME ]; do
            # Get all release jobs for this workflow run
            JOBS=$(gh api "repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" --paginate --jq '.jobs[] | select(.name | startswith("üöÄ Release"))' || echo "[]")

            # Count failed jobs
            FAILED_COUNT=$(echo "$JOBS" | jq -r 'select(.conclusion == "failure" or .conclusion == "cancelled" or .conclusion == "timed_out") | .name' | grep -c . || echo "0")
            FAILED_COUNT=$((FAILED_COUNT + 0)) # Ensure integer

            # Count successful skipped jobs
            SKIPPED_COUNT=$(echo "$JOBS" | jq -r 'select(.conclusion == "success" and (.name | contains("skipped") or contains("Skipped"))) | .name' | grep -c . || echo "0")
            SKIPPED_COUNT=$((SKIPPED_COUNT + 0)) # Ensure integer

            TOTAL_COUNT=$(echo "$JOBS" | jq -r '.name' | grep -c . || echo "0")
            TOTAL_COUNT=$((TOTAL_COUNT + 0)) # Ensure integer

            RUNNING_COUNT=$(echo "$JOBS" | jq -r 'select(.status == "queued" or .status == "in_progress") | .name' | grep -c . || echo "0")
            RUNNING_COUNT=$((RUNNING_COUNT + 0)) # Ensure integer

            echo "[$(date +'%H:%M:%S')] Status: $FAILED_COUNT failed, $SKIPPED_COUNT skipped (successful), $RUNNING_COUNT running, $TOTAL_COUNT total"

            # Check if skipped threshold reached
            if [ "$SKIPPED_COUNT" -ge "$MAX_SKIPPED_SUCCESS" ]; then
              echo ""
              echo "‚úÖ Threshold reached: $SKIPPED_COUNT successful skipped addons (threshold: $MAX_SKIPPED_SUCCESS)"
              echo "‚ÑπÔ∏è  Most addons are likely working. Stopping monitor (builds will continue running)."
              echo ""
              echo "‚úÖ Monitor completed early: $SKIPPED_COUNT successful skipped addons detected. Remaining releases will continue."
              exit 0
            fi

            # Check if failure threshold reached
            if [ "$FAILED_COUNT" -ge "$MAX_FAILURES" ]; then
              echo ""
              echo "‚ùå Threshold reached: $FAILED_COUNT failures (threshold: $MAX_FAILURES)"
              echo "‚ö†Ô∏è  WARNING: Too many addons have failed. Cancelling remaining release jobs..."

              # Get all release jobs that are still queued or in_progress
              RUNNING_JOBS=$(echo "$JOBS" | jq -r 'select(.status == "queued" or .status == "in_progress") | .id')

              if [ -z "$RUNNING_JOBS" ] || [ "$RUNNING_JOBS" = "" ]; then
                echo "‚ÑπÔ∏è  No remaining jobs to cancel"
              else
                CANCELLED_COUNT=0
                while IFS= read -r JOB_ID; do
                  if [ -n "$JOB_ID" ] && [ "$JOB_ID" != "null" ]; then
                    echo "Cancelling job ID: $JOB_ID"
                    gh api "repos/${{ github.repository }}/actions/jobs/$JOB_ID" -X POST -f state=cancelled 2>/dev/null || echo "  (Job $JOB_ID may have already completed)"
                    ((CANCELLED_COUNT++)) || true
                  fi
                done <<< "$RUNNING_JOBS"

                echo "‚úÖ Cancelled $CANCELLED_COUNT remaining release job(s)"
              fi

              echo ""
              echo "‚ö†Ô∏è  WARNING: Too many addons failed ($FAILED_COUNT/$MAX_FAILURES threshold). Remaining releases have been cancelled."
              exit 0
            fi

            # If no more running jobs, exit
            if [ "$RUNNING_COUNT" -eq 0 ]; then
              echo ""
              echo "‚úÖ All release jobs completed. Final status: $FAILED_COUNT failed, $SKIPPED_COUNT skipped (successful) out of $TOTAL_COUNT total"
              exit 0
            fi

            # Wait before next check
            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done

          echo ""
          echo "‚è±Ô∏è  Monitor timeout reached. Jobs may still be running."
        env:
          GH_TOKEN: ${{ secrets.PAT || secrets.GITHUB_TOKEN }}

  # ================================================================================
  # CLEANUP: Prune Docker Registry after "all" releases
  # ================================================================================
  cleanup-registry:
    name: üßπ Cleanup Docker Registry
    needs: [detect, release, monitor-failures]
    if: |
      always() &&
      needs.detect.outputs.is_all == 'true' &&
      (needs.release.result == 'success' || needs.release.result == 'failure' || needs.release.result == 'cancelled')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v6

      - name: üêç Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.x"

      - name: üì¶ Install Python Dependencies
        run: pip install requests pyyaml --quiet

      - name: üóëÔ∏è Prune Docker Registry
        run: python3 .scripts/prune_registry.py
        env:
          GITHUB_TOKEN: ${{ secrets.PAT || secrets.GITHUB_TOKEN }} # Needs delete:packages scope
          GITHUB_REPOSITORY_OWNER: ${{ github.repository_owner }}
