name: Cleanup PR Artifacts

on:
  pull_request:
    types: [closed]

jobs:
  cleanup:
    # Only run when PR is merged (not just closed)
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    permissions:
      actions: write
    steps:
      - name: ðŸ§¹ Cleanup PR Workflow Runs and Artifacts
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const headSha = context.payload.pull_request.head.sha;

            console.log(`Cleaning up artifacts for merged PR #${prNumber}`);

            // Get all workflow runs for this PR's head branch/SHA (with pagination)
            const runs = [];
            let page = 1;
            while (true) {
                const { data: response } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  event: 'pull_request',
                  status: 'completed',
                  per_page: 100,
                  page: page
                });
                if (response.workflow_runs.length === 0) break;
                runs.push(...response.workflow_runs);
                if (runs.length >= 500) break; // Safety limit
                page++;
            }

            // Filter runs related to this PR
            const prRuns = runs.filter(run =>
              run.head_sha === headSha ||
              run.pull_requests.some(pr => pr.number === prNumber)
            );

            console.log(`Found ${prRuns.length} workflow runs for PR #${prNumber}`);

            if (prRuns.length === 0) {
              console.log("No runs to clean up.");
              return;
            }

            // Sort by created_at descending (newest first)
            prRuns.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            // Check if the last run failed or was cancelled
            const lastRun = prRuns[0];
            const lastRunFailed = lastRun.conclusion === 'failure' || lastRun.conclusion === 'cancelled';

            if (lastRunFailed) {
              console.log(`Last run ${lastRun.id} failed/cancelled. Keeping it for debugging.`);
              // Remove the last run from cleanup list
              prRuns.shift();
            }

            // Delete old runs and their artifacts
            for (const run of prRuns) {
              console.log(`Deleting run ${run.id} (${run.name}) from ${run.created_at}`);

              // Delete artifacts for this run
              try {
                const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id,
                });

                for (const artifact of artifacts.artifacts) {
                  try {
                    console.log(`  Deleting artifact: ${artifact.name}`);
                    await github.rest.actions.deleteArtifact({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      artifact_id: artifact.id,
                    });
                  } catch (e) {
                    console.log(`  Failed to delete artifact ${artifact.name}: ${e.message}`);
                  }
                }
              } catch (e) {
                console.log(`  Could not list artifacts: ${e.message}`);
              }

              // Delete the workflow run
              try {
                await github.rest.actions.deleteWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id,
                });
              } catch (e) {
                console.log(`  Could not delete run: ${e.message}`);
              }
            }

            console.log("Cleanup complete!");
