name: Orchestrator Cleanup

permissions:
  actions: write
  deployments: write

on:
  pull_request:
    types: [closed]
  schedule:
    # Run weekly on Sundays at 3:00 AM UTC
    - cron: "0 3 * * 0"
  workflow_dispatch:

jobs:
  cleanup-pr-artifacts:
    # Only run when PR is merged (not just closed)
    if: github.event_name == 'pull_request' && github.event.pull_request.merged == true
    name: ðŸ§¹ Cleanup PR Artifacts
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ§¹ Cleanup PR Workflow Runs and Artifacts
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const headSha = context.payload.pull_request.head.sha;

            console.log(`Cleaning up artifacts for merged PR #${prNumber}`);

            // Get all workflow runs for this PR's head branch/SHA (with pagination)
            const runs = [];
            let page = 1;
            while (true) {
                const { data: response } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  event: 'pull_request',
                  status: 'completed',
                  per_page: 100,
                  page: page
                });
                if (response.workflow_runs.length === 0) break;
                runs.push(...response.workflow_runs);
                if (runs.length >= 500) break; // Safety limit
                page++;
            }

            // Filter runs related to this PR
            const prRuns = runs.filter(run =>
              run.head_sha === headSha ||
              run.pull_requests.some(pr => pr.number === prNumber)
            );

            console.log(`Found ${prRuns.length} workflow runs for PR #${prNumber}`);

            if (prRuns.length === 0) {
              console.log("No runs to clean up.");
              return;
            }

            // Sort by created_at descending (newest first)
            prRuns.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            // Check if the last run failed or was cancelled
            const lastRun = prRuns[0];
            const lastRunFailed = lastRun.conclusion === 'failure' || lastRun.conclusion === 'cancelled';

            if (lastRunFailed) {
              console.log(`Last run ${lastRun.id} failed/cancelled. Keeping it for debugging.`);
              // Remove the last run from cleanup list
              prRuns.shift();
            }

            // Delete old runs and their artifacts
            for (const run of prRuns) {
              console.log(`Deleting run ${run.id} (${run.name}) from ${run.created_at}`);

              // Delete artifacts for this run
              try {
                const { data: artifacts } = await github.rest.actions.listWorkflowRunArtifacts({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id,
                });

                for (const artifact of artifacts.artifacts) {
                  try {
                    console.log(`  Deleting artifact: ${artifact.name}`);
                    await github.rest.actions.deleteArtifact({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      artifact_id: artifact.id,
                    });
                  } catch (e) {
                    console.log(`  Failed to delete artifact ${artifact.name}: ${e.message}`);
                  }
                }
              } catch (e) {
                console.log(`  Could not list artifacts: ${e.message}`);
              }

              // Delete the workflow run
              try {
                await github.rest.actions.deleteWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id,
                });
              } catch (e) {
                console.log(`  Could not delete run: ${e.message}`);
              }
            }

            console.log("Cleanup complete!");

  cleanup-deployments:
    # Run on schedule or manual trigger (not on PR events)
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    name: ðŸ—‘ï¸ Cleanup Stale Deployments
    runs-on: ubuntu-latest
    steps:
      - name: ðŸ—‘ï¸ Delete Old Deployments (Keep Recent 10)
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const KEEP_RECENT = 10; // Number of recent deployments to keep
            console.log(`Starting deployment cleanup (keeping ${KEEP_RECENT} most recent)...`);

            // First, collect all deployments
            const allDeployments = [];
            let page = 1;
            const perPage = 100;

            while (true) {
              const { data: deployments } = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: perPage,
                page: page
              });

              if (deployments.length === 0) break;
              allDeployments.push(...deployments);

              // Safety limit
              if (allDeployments.length >= 10000) break;
              page++;
            }

            console.log(`Found ${allDeployments.length} total deployments.`);

            if (allDeployments.length <= KEEP_RECENT) {
              console.log(`Only ${allDeployments.length} deployments exist. Nothing to clean up.`);
              return;
            }

            // Sort by created_at descending (newest first)
            allDeployments.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

            // Skip the most recent ones
            const deploymentsToDelete = allDeployments.slice(KEEP_RECENT);
            console.log(`Keeping ${KEEP_RECENT} recent deployments. Deleting ${deploymentsToDelete.length}...`);

            let deleted = 0;
            for (const deployment of deploymentsToDelete) {
              try {
                // First, set status to inactive (required before deletion)
                await github.rest.repos.createDeploymentStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: deployment.id,
                  state: 'inactive'
                });

                // Then delete the deployment
                await github.rest.repos.deleteDeployment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: deployment.id
                });

                deleted++;
                if (deleted % 100 === 0) {
                  console.log(`Deleted ${deleted} deployments so far...`);
                }
              } catch (e) {
                console.log(`Failed to delete deployment ${deployment.id}: ${e.message}`);
              }

              // Safety limit per run
              if (deleted >= 5000) {
                console.log("Reached safety limit of 5000 deletions per run. Run again for more.");
                break;
              }
            }

            console.log(`Deployment cleanup complete! Deleted ${deleted} deployments. Kept ${KEEP_RECENT} recent.`);
