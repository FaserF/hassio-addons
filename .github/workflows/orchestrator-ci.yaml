name: Orchestrator CI

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # --------------------------------------------------------------------------------
  # CI START: Post initial comment
  # --------------------------------------------------------------------------------
  ci_start:
    name: üöÄ CI Start Notification
    if: github.event_name == 'pull_request' && github.event.action == 'opened'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
    steps:
      - name: üìù Post CI Starting Comment
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
               owner: context.repo.owner,
               repo: context.repo.repo,
               issue_number: context.issue.number,
            });

            const signature = "<!-- ci-start-comment -->";
            const previousComments = comments.filter(c => c.user.type === 'Bot' && c.body.includes(signature));

            // Minimize old start comments
            for (const comment of previousComments) {
                try {
                    await github.graphql(`
                        mutation($subjectId: ID!) {
                            minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                                minimizedComment { isMinimized }
                            }
                        }
                    `, { subjectId: comment.node_id });
                } catch (error) {
                    console.error(`Failed to minimize comment ${comment.id}:`, error);
                }
            }

            let body = signature + "\n";
            body += "## üîÑ CI Tests Running\n\n";
            body += "Comprehensive CI tests are now running. This may take a few minutes.\n\n";
            body += "A detailed feedback comment will be posted once all checks are complete.\n\n";
            body += "---\n\n";
            body += "**üìã Merge Policy:**\n";
            body += "- PRs are typically only merged when **all CI tests pass**\n";
            body += "- If tests fail, you will receive automated guidance on how to fix the issues\n";
            body += "- PRs with failing tests may receive limited maintainer attention until resolved\n\n";
            body += "_*Workflow configuration errors are handled by maintainers_";

            await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
            });

  # --------------------------------------------------------------------------------
  # FILTER: Detect which add-ons have changed
  # --------------------------------------------------------------------------------
  generate-config:
    name: üß© Generate Config
    runs-on: ubuntu-latest
    outputs:
      filters: ${{ steps.generator.outputs.filters }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4

      - name: üêç Generate Dynamic Filters
        id: generator
        run: |
          import os
          import json
          import uuid

          filters = {}
          # Scan for config.yaml to identify add-ons
          for root, dirs, files in os.walk("."):
              if "config.yaml" in files:
                  addon_name = os.path.relpath(root, ".")
                  if addon_name == ".": continue

                  # Standardize path separators
                  addon_name = addon_name.replace(os.path.sep, "/")

                  # Skip hidden directories EXCEPT .unsupported
                  # If the path starts with . and is NOT .unsupported, skip
                  # If the path is inside a hidden dir (like .git/foo), skip
                  parts = addon_name.split("/")
                  if parts[0].startswith(".") and parts[0] != ".unsupported":
                      continue
                  if len(parts) > 1 and any(p.startswith(".") and p != ".unsupported" for p in parts):
                       # This handles .unsupported/addon (allowed) but skips .git/addon or addon/.hidden
                       continue

                  filters[addon_name] = [f"{addon_name}/**"]

          # Dump as JSON (valid YAML)
          json_content = json.dumps(filters)

          delimiter = str(uuid.uuid4())
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"filters<<{delimiter}\n")
              f.write(json_content)
              f.write(f"\n{delimiter}\n")

        shell: python

  # --------------------------------------------------------------------------------
  # FILTER: Detect which add-ons have changed
  # --------------------------------------------------------------------------------
  filter:
    name: üîç Detect Changes
    needs: generate-config
    runs-on: ubuntu-latest
    outputs:
      addons: ${{ steps.filter.outputs.changes }}
      docs_only: ${{ steps.change-type.outputs.docs_only }}
      needs_build: ${{ steps.change-type.outputs.needs_build }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìÇ Run Paths Filter
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: ${{ needs.generate-config.outputs.filters }}

      - name: üîé Analyze Change Types
        id: change-type
        run: |
          # Get all changed files in this push/PR
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }} 2>/dev/null || git diff --name-only HEAD~1)
          else
            CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Categorize changes
          docs_only="true"
          needs_build="false"

          for file in $CHANGED_FILES; do
            # Check if file requires build (Dockerfile, config, scripts, etc.)
            if [[ "$file" == */Dockerfile ]] || \
               [[ "$file" == */build.yaml ]] || \
               [[ "$file" == */build.json ]] || \
               [[ "$file" == */config.yaml ]] || \
               [[ "$file" == */config.json ]] || \
               [[ "$file" == *run.sh ]] || \
               [[ "$file" == *.py ]] || \
               [[ "$file" == */rootfs/* ]] || \
               [[ "$file" == */root/* ]]; then
              needs_build="true"
              docs_only="false"
            # Check if it's NOT a documentation/workflow file
            elif [[ "$file" != *.md ]] && \
                 [[ "$file" != *.MD ]] && \
                 [[ "$file" != .github/workflows/* ]] && \
                 [[ "$file" != .github/*.md ]] && \
                 [[ "$file" != LICENSE* ]] && \
                 [[ "$file" != */CHANGELOG* ]] && \
                 [[ "$file" != .gitignore ]] && \
                 [[ "$file" != .editorconfig ]]; then
              docs_only="false"
            fi
          done

          echo "docs_only=$docs_only" >> $GITHUB_OUTPUT
          echo "needs_build=$needs_build" >> $GITHUB_OUTPUT
          echo "Results: docs_only=$docs_only, needs_build=$needs_build"

  # --------------------------------------------------------------------------------
  # LINT: Static Analysis (Fail Fast)
  # --------------------------------------------------------------------------------
  lint:
    name: üßπ Lint & Validate
    needs: filter
    if: needs.filter.outputs.addons != '[]' && needs.filter.outputs.addons != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    strategy:
      fail-fast: false
      matrix:
        addon: ${{ fromJSON(needs.filter.outputs.addons) }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4

      # 1. ShellCheck
      - name: üêö ShellCheck
        uses: ludeeus/action-shellcheck@2.0.0
        with:
          scandir: "./${{ matrix.addon }}"
        env:
          SHELLCHECK_OPTS: -s bash -e SC2086

      # 2. Hadolint
      - name: üê≥ Hadolint
        uses: brpaz/hadolint-action@v1.5.0
        with:
          dockerfile: "./${{ matrix.addon }}/Dockerfile"

      # 3. Common Linters (Markdown/YAML/JSON/Prettier)
      # We run these once per add-on to ensure focus, or globally if preferred.
      # Running per add-on allows cleaner failure reporting.
      - name: üìù MarkdownLint
        continue-on-error: true
        uses: actionshub/markdownlint@v3.1.4
        with:
          args: "${{ matrix.addon }}/*.md"

      - name: üìÑ YAMLLint
        continue-on-error: true
        uses: frenck/action-yamllint@v1.5
        with:
          args: "./${{ matrix.addon }}/*.yaml"

      - name: üíÖ Prettier
        continue-on-error: true
        run: |
          npm install -g prettier
          prettier --check "${{ matrix.addon }}/**/*.{json,js,md,yaml}" --ignore-path .prettierignore

      # 4. Add-on Linter (Frenck's) - Validates config.yaml/json
      - name: üïµÔ∏è Add-on Linter
        uses: frenck/action-addon-linter@v2
        with:
          path: "./${{ matrix.addon }}"
        continue-on-error: ${{ matrix.addon == 'netboot-xyz' }}

      # 5. Platinum Compliance (S6, Healthcheck, OCI, Translations, Images)
      - name: üì¶ Install Compliance Deps
        run: pip install pyyaml

      - name: üèÜ Platinum Compliance Check
        id: compliance
        continue-on-error: true
        run: |
          set +e
          # Add addon name as header for report aggregation
          echo "ADDON: ${{ matrix.addon }}" > compliance_report.txt
          python3 .scripts/check_compliance.py "./${{ matrix.addon }}" >> compliance_report.txt 2>&1
          exit_code=$?
          set -e

          echo "::group::Compliance Report"
          cat compliance_report.txt
          echo "::endgroup::"

          if [ $exit_code -ne 0 ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi

      - name: üì§ Upload Compliance Report
        if: steps.compliance.outputs.status == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: compliance-${{ github.run_id }}-${{ strategy.job-index }}
          path: compliance_report.txt
          retention-days: 1

      - name: üõë Fail if Compliance Error
        if: steps.compliance.outputs.status == 'failure'
        run: |
          echo "::error::Compliance checks failed! See 'Platinum Compliance Check' step for details."
          cat compliance_report.txt
          exit 1

      # 6. Security Scan (Trivy)
      # Scanning the directory for vulnerabilities (fs mode)
      # Note: Scanning the built image is better, but this scans deps/conf before build.
      - name: üõ°Ô∏è Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "./${{ matrix.addon }}"
          ignore-unfixed: true
          severity: "CRITICAL,HIGH"

  # --------------------------------------------------------------------------------
  # BUILD: Test Build (No Push)
  # --------------------------------------------------------------------------------
  build:
    name: üèóÔ∏è Test Build (${{ matrix.addon }})
    needs: [filter, lint]
    # Skip build if only docs/workflows changed (no Dockerfile, config, scripts)
    if: |
      needs.filter.outputs.addons != '[]' &&
      needs.filter.outputs.addons != '' &&
      needs.filter.outputs.needs_build == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      # Only matrix on addons, build all arches sequentially on same runner
      matrix:
        addon: ${{ fromJSON(needs.filter.outputs.addons) }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üíæ Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ matrix.addon }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ matrix.addon }}-
            ${{ runner.os }}-buildx-

      - name: ‚ÑπÔ∏è Get Add-on Info
        id: info
        uses: home-assistant/actions/helpers/info@master
        with:
          path: "./${{ matrix.addon }}"

      - name: üèóÔ∏è Build All Architectures
        run: |
          ARCHS="${{ steps.info.outputs.architectures }}"
          IMAGE=$(echo "${{ steps.info.outputs.image }}" | cut -d'/' -f3)

          echo "Building ${{ matrix.addon }} for architectures: $ARCHS"

          for arch in $ARCHS; do
            # Skip 32-bit architectures (deprecated)
            if [[ "$arch" == "armhf" || "$arch" == "armv7" || "$arch" == "i386" ]]; then
              echo "‚è≠Ô∏è Skipping deprecated architecture: $arch"
              continue
            fi

            echo "üî® Building for $arch..."
            docker run --rm --privileged \
              -v /var/run/docker.sock:/var/run/docker.sock \
              -v "$(pwd)":/data \
              -v /tmp/.buildx-cache:/cache \
              ghcr.io/home-assistant/amd64-builder:2025.11.0 \
              --test \
              --$arch \
              --target /data/${{ matrix.addon }} \
              --image "$IMAGE" \
              --docker-hub "ghcr.io/${{ github.repository_owner }}" \
              --addon \
              --cache-from type=local,src=/cache \
              --cache-to type=local,dest=/cache,mode=max || exit 1
          done

          echo "‚úÖ All architectures built successfully"

  report:
    name: üìä CI & Compliance Report
    needs: [filter, lint, build]
    if: failure() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      actions: read
    steps:
      - name: üì• Download Compliance Artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: compliance-*
          merge-multiple: false
          path: reports

      - name: üìù Post Platinum Compliance Report
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            if (!fs.existsSync('reports')) {
                console.log("No compliance reports found.");
                return;
            }

            const dirs = fs.readdirSync('reports').filter(f => fs.statSync(path.join('reports', f)).isDirectory());
            let summary = "## üõ°Ô∏è Platinum Compliance Issues\n\nThe following add-ons failed compliance checks:\n\n";
            let hasContent = false;
            let totalIssues = 0;
            let missingHealthchecks = 0;
            let missingLogos = 0;
            let addonsWithHealthcheckIssue = [];
            let addonsWithLogoIssue = [];

            for (const dir of dirs) {
                const reportPath = path.join('reports', dir, 'compliance_report.txt');
                if (fs.existsSync(reportPath)) {
                   const content = fs.readFileSync(reportPath, 'utf8');
                   // Extract addon name from "ADDON: xyz" header line
                   const addonMatch = content.match(/^ADDON: (.+)$/m);
                   const addonName = addonMatch ? addonMatch[1] : dir.replace('compliance-', '');
                   // Remove the ADDON line from display content
                   const displayContent = content.replace(/^ADDON: .+\n/, '');

                   if (content.includes("HEALTHCHECK")) {
                       missingHealthchecks++;
                       addonsWithHealthcheckIssue.push(addonName);
                   }
                   if (content.includes("logo.png")) {
                       missingLogos++;
                       addonsWithLogoIssue.push(addonName);
                   }
                   totalIssues++;

                   summary += `<details>\n<summary><strong>${addonName}</strong>: ‚ùå Issues Found</summary>\n\n\`\`\`\n${displayContent}\n\`\`\`\n</details>\n\n`;
                   hasContent = true;
                }
            }

            // AI Summary Simulation
            summary += `<details>\n<summary>ü§ñ <strong>AI Summary (Effective Fix Strategy)</strong></summary>\n\n`;
            summary += `> [!TIP]\n> **Quick Fix Analysis**\n>\n`;

            let fixList = "";
            if (missingHealthchecks > 0) {
                fixList += `${missingHealthchecks}x Missing HEALTHCHECK:\n`;
                for (const addon of addonsWithHealthcheckIssue) {
                    fixList += `  ‚Üí ${addon}/Dockerfile\n`;
                }
                fixList += `  Fix: Add 'HEALTHCHECK CMD curl --fail http://127.0.0.1:PORT || exit 1'\n\n`;
            }
            if (missingLogos > 0) {
                fixList += `${missingLogos}x Missing logo.png:\n`;
                for (const addon of addonsWithLogoIssue) {
                    fixList += `  ‚Üí ${addon}/logo.png\n`;
                }
                fixList += `  Fix: Add 500x500px logo.png to addon root\n`;
            }

            summary += `\`\`\`text\nFound ${totalIssues} add-on${totalIssues > 1 ? 's' : ''} with issues.\n\n${fixList}\`\`\`\n`;
            summary += `\n</details>\n\n`;

            summary += "\nüíé **Platinum Standards:**\n- Translations (EN/DE)\n- Images (Icon/Logo)\n- Official Base Image\n- S6 Overlay & Healthchecks";

            if (hasContent) {
                // Find existing comments by this bot with signature
                const { data: comments } = await github.rest.issues.listComments({
                   owner: context.repo.owner,
                   repo: context.repo.repo,
                   issue_number: context.issue.number,
                });

                const signature = "## üõ°Ô∏è Platinum Compliance Issues";
                const previousComments = comments.filter(c => c.user.type === 'Bot' && c.body.includes(signature));

                for (const comment of previousComments) {
                    try {
                        await github.graphql(`
                            mutation($subjectId: ID!) {
                                minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                                    minimizedComment {
                                        isMinimized
                                    }
                                }
                            }
                        `, { subjectId: comment.node_id });
                    } catch (error) {
                        console.error(`Failed to minimize comment ${comment.id}:`, error);
                    }
                }

                await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: summary
                });

                // Add ci/platinum-issues label (if only platinum issues, not general failures)
                const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                });

                // Only add platinum-issues if ci/failed is not already set
                const hasFailedLabel = currentLabels.some(l => l.name === 'ci/failed');
                if (!hasFailedLabel) {
                    const ciLabels = ['ci/passed', 'ci/failed', 'ci/platinum-issues'];
                    const filteredLabels = currentLabels.map(l => l.name).filter(n => !ciLabels.includes(n));
                    filteredLabels.push('ci/platinum-issues');

                    await github.rest.issues.setLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: context.issue.number,
                        labels: filteredLabels
                    });
                }
            }

      - name: üìù Post General CI Failure Report
        uses: actions/github-script@v7
        with:
          script: |
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });

            const failedJobs = jobs.jobs.filter(j => j.conclusion === 'failure');
            if (failedJobs.length === 0) return;

            // Filter out Compliance-only failures (handled by Platinum Report)
            const nonComplianceJobs = failedJobs.filter(job => {
                const failedStep = job.steps.find(s => s.conclusion === 'failure');
                const stepName = failedStep ? failedStep.name : "";
                return !stepName.includes("Compliance");
            });

            // If all failures are Compliance-related, skip this report (Platinum Report handles it)
            if (nonComplianceJobs.length === 0) {
                console.log("All failures are Compliance-related. Skipping General CI Report.");
                return;
            }

            let report = "## ‚ùå General CI Failure Report\n\nSome checks failed. Here is the diagnostic summary:\n\n";

            // Failed Jobs List (excluding Compliance)
            report += "| Job | Step | Message |\n|---|---|---|\n";
            let affectedAddons = new Set();
            let specificTests = new Set();
            let failureTypes = new Set();

            for (const job of nonComplianceJobs) {
                // Regex to capture "addon" from: "Job Name (addon)" or "Job Name (addon - arch)"
                const match = job.name.match(/\((.*?)(?: -.*)?\)/);
                if (match) affectedAddons.add(match[1]);

                const failedStep = job.steps.find(s => s.conclusion === 'failure');
                const stepName = failedStep ? failedStep.name : "Unknown Step";
                report += `| ${job.name} | ${stepName} | See logs |\n`;

                // Categorize Failure (excluding Compliance)
                if (stepName.includes("Lint") || stepName.includes("Check") || stepName.includes("Prettier")) failureTypes.add("Linting/Static Analysis");
                if (stepName.includes("Build") || job.name.includes("Build")) failureTypes.add("Docker Build");
                if (stepName.includes("Trivy")) failureTypes.add("Security Scan");
                if (stepName.includes("ShellCheck")) failureTypes.add("ShellCheck");
                if (stepName.includes("Hadolint")) failureTypes.add("Hadolint");

                // Map failed step/job to verification script test name
                if (stepName.includes("ShellCheck")) specificTests.add("ShellCheck");
                else if (stepName.includes("Hadolint")) specificTests.add("Hadolint");
                else if (stepName.includes("MarkdownLint")) specificTests.add("MarkdownLint");
                else if (stepName.includes("YAMLLint")) specificTests.add("YamlLint");
                else if (stepName.includes("Prettier")) specificTests.add("Prettier");
                else if (stepName.includes("Add-on Linter")) specificTests.add("AddonLinter");
                else if (stepName.includes("Trivy")) specificTests.add("Trivy");
                else if (job.name.includes("Build")) specificTests.add("DockerBuild");
            }
            report += "\n";

            // AI Summary (as code block for easy copying)
            report += `<details>\n<summary>ü§ñ <strong>AI Summary (Diagnostic)</strong></summary>\n\n`;

            // Pre-calculate the test command to include in both AI summary and separate section
            let testsArg = "";
            if (specificTests.size > 0) {
                testsArg = ` -Tests "${Array.from(specificTests).join('","')}"`;
            }

            let testCommand = "";
            if (affectedAddons.size > 0) {
                // List all affected addons in one command
                const addonsList = Array.from(affectedAddons).join('","');
                testCommand = `.\\.scripts\\verify_addons.ps1 -Addon "${addonsList}" -Fix${testsArg}`;
            } else {
                testCommand = `.\\.scripts\\verify_addons.ps1 -Addon all -Fix${testsArg}`;
            }

            let aiText = "";
            if (affectedAddons.size > 0) {
                 aiText += `Affected Add-ons: ${Array.from(affectedAddons).join(', ')}\n`;
                 aiText += `Failure Categories: ${Array.from(failureTypes).join(', ')}\n\n`;
                 aiText += `Local Test Command:\n${testCommand}`;
            } else {
                 aiText += `Global Workflow Failure: A critical error occurred outside specific add-on checks. Check the workflow logs.`;
            }
            report += `\`\`\`text\n${aiText}\n\`\`\`\n`;
            report += `\n</details>\n\n`;

            // Local Test Command (expanded section)
            report += `<details open>\n<summary>üíª <strong>Local Test Command</strong></summary>\n\n`;
            report += "Run this command locally to reproduce and fix issues:\n\n";
            report += "**PowerShell:**\n";
            report += "```powershell\n";
            report += testCommand + "\n";
            report += "```\n\n";

            const bashCommand = testCommand.replace(/\\/g, '/').replace(/^\.\//, './');
            report += "**Bash:**\n";
            report += "```bash\n";
            report += bashCommand + "\n";
            report += "```\n";
            report += "\n</details>";

            const signature = "<!-- general-ci-failure-report -->";
            const reportBody = signature + "\n" + report;

            // Find and minimize old failure reports
            const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
            });

            // Standardize old signatures too for transition
            const oldSignatures = ["## ‚ùå General CI Failure Report", signature];
            const previousComments = comments.filter(c => c.user.type === 'Bot' && oldSignatures.some(sig => c.body.includes(sig)));

            for (const comment of previousComments) {
                try {
                    await github.graphql(`
                        mutation($subjectId: ID!) {
                            minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                                minimizedComment { isMinimized }
                            }
                        }
                    `, { subjectId: comment.node_id });
                } catch (error) {
                    console.error(`Failed to minimize comment ${comment.id}:`, error);
                }
            }

            // Post General Report
            await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: reportBody
            });

            // Update CI status labels to ci/failed
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
            });

            const ciLabels = ['ci/passed', 'ci/failed', 'ci/platinum-issues'];
            const filteredLabels = currentLabels.map(l => l.name).filter(n => !ciLabels.includes(n));
            filteredLabels.push('ci/failed');

            await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: filteredLabels
            });

  success_report:
    name: ‚úÖ CI Success Summary
    needs: [filter, lint, build]
    # Run when lint passes and build passes OR was skipped (docs-only changes)
    if: |
      always() &&
      github.event_name == 'pull_request' &&
      needs.lint.result == 'success' &&
      (needs.build.result == 'success' || needs.build.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: üìù Post Success Comment
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
               owner: context.repo.owner,
               repo: context.repo.repo,
               issue_number: context.issue.number,
            });

            // Signatures of comments to minimize (cleanup old failures and summaries)
            const signatures = [
                "<!-- ci-start-comment -->",
                "## üõ°Ô∏è Platinum Compliance Issues",
                "<!-- general-ci-failure-report -->",
                "## ‚ùå General CI Failure Report",
                "## ‚úÖ Verification Successful"
            ];

            const commentsToMinimize = comments.filter(c =>
                c.user.type === 'Bot' &&
                signatures.some(sig => c.body.includes(sig))
            );

            for (const comment of commentsToMinimize) {
                try {
                    await github.graphql(`
                        mutation($subjectId: ID!) {
                            minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                                minimizedComment {
                                    isMinimized
                                }
                            }
                        }
                    `, { subjectId: comment.node_id });
                } catch (error) {
                    console.error(`Failed to minimize comment ${comment.id}:`, error);
                }
            }

            // Check if author is maintainer/bot for auto-merge message
            const author = context.payload.pull_request.user.login;
            const isMaintainer = ['FaserF', 'dependabot[bot]', 'renovate[bot]'].includes(author);

            let autoMergeNote = "";
            if (isMaintainer) {
                autoMergeNote = "\n\n‚è±Ô∏è **Auto-merge will be enabled in 1 minute** if branch protection rules are satisfied.\n\n> üõë To cancel: Add the `no-merge` label or run `gh pr merge --disable-auto`";
            }

            // Check if build was skipped (docs-only changes)
            const buildSkipped = '${{ needs.build.result }}' === 'skipped';
            const buildStatus = buildSkipped ? "‚è≠Ô∏è Skipped (docs-only)" : "‚úÖ Successful";

            // Check for unresolved errors from previous runs
            let previousErrorsNote = "";
            try {
                // Get previous workflow runs for this PR
                const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    event: 'pull_request',
                    status: 'completed',
                    per_page: 10,
                });

                // Filter runs for this PR that failed
                const prRuns = runs.workflow_runs.filter(run =>
                    run.pull_requests &&
                    run.pull_requests.some(pr => pr.number === context.issue.number) &&
                    run.id !== parseInt('${{ github.run_id }}')
                );

                const failedRuns = prRuns.filter(run => run.conclusion === 'failure');

                // Check what files were changed in those failed runs vs now
                if (failedRuns.length > 0 && buildSkipped) {
                    // Build was skipped but there were previous failures
                    // This means the previous failures might still exist!
                    previousErrorsNote = "\n\n> ‚ö†Ô∏è **Note**: Build was skipped for this commit, but there were failed runs earlier in this PR. Make sure all previous issues with Dockerfiles/configs are resolved.";
                }
            } catch (e) {
                console.log("Could not check previous runs:", e.message);
            }


            let body = "## ‚úÖ Verification Successful\n\n";
            body += "Thank you for your contribution!\n\n";
            body += "- üõ°Ô∏è **Platinum Standards**: Compliant\n";
            body += "- üü¢ **CI Checks**: Passed\n";
            body += "- üèóÔ∏è **Build**: " + buildStatus + "\n\n";
            body += "This PR meets high quality standards and is ready for review.";
            body += previousErrorsNote;
            body += autoMergeNote;

            // Check if we already posted a success comment to avoid spamming
            const alreadyPosted = comments.find(c => c.user.type === 'Bot' && c.body.includes("## ‚úÖ Verification Successful"));

            if (!alreadyPosted) {
                await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: body
                });
            }

            // Update CI status labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
            });

            const ciLabels = ['ci/passed', 'ci/failed', 'ci/platinum-issues'];
            const filteredLabels = currentLabels.map(l => l.name).filter(n => !ciLabels.includes(n));
            filteredLabels.push('ci/passed');

            await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: filteredLabels
            });

            // Minimize the CI start comment
            const startComment = comments.find(c => c.user.type === 'Bot' && c.body.includes("<!-- ci-start-comment -->"));
            if (startComment) {
                try {
                    await github.graphql(`
                        mutation($subjectId: ID!) {
                            minimizeComment(input: {subjectId: $subjectId, classifier: RESOLVED}) {
                                minimizedComment { isMinimized }
                            }
                        }
                    `, { subjectId: startComment.node_id });
                } catch (e) { console.log("Could not minimize start comment"); }
            }
