name: Orchestrator CI

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # --------------------------------------------------------------------------------
  # FILTER: Detect which add-ons have changed
  # --------------------------------------------------------------------------------
  generate-config:
    name: üß© Generate Config
    runs-on: ubuntu-latest
    outputs:
      filters: ${{ steps.generator.outputs.filters }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4

      - name: üêç Generate Dynamic Filters
        id: generator
        run: |
          import os
          import json
          import uuid

          filters = {}
          # Scan for config.yaml to identify add-ons
          for root, dirs, files in os.walk("."):
              if "config.yaml" in files:
                  addon_name = os.path.relpath(root, ".")
                  if addon_name == ".": continue

                  # Standardize path separators
                  addon_name = addon_name.replace(os.path.sep, "/")

                  # Skip hidden directories EXCEPT .unsupported
                  # If the path starts with . and is NOT .unsupported, skip
                  # If the path is inside a hidden dir (like .git/foo), skip
                  parts = addon_name.split("/")
                  if parts[0].startswith(".") and parts[0] != ".unsupported":
                      continue
                  if len(parts) > 1 and any(p.startswith(".") and p != ".unsupported" for p in parts):
                       # This handles .unsupported/addon (allowed) but skips .git/addon or addon/.hidden
                       continue

                  filters[addon_name] = [f"{addon_name}/**"]

          # Dump as JSON (valid YAML)
          json_content = json.dumps(filters)

          delimiter = str(uuid.uuid4())
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"filters<<{delimiter}\n")
              f.write(json_content)
              f.write(f"\n{delimiter}\n")

        shell: python

  # --------------------------------------------------------------------------------
  # FILTER: Detect which add-ons have changed
  # --------------------------------------------------------------------------------
  filter:
    name: üîç Detect Changes
    needs: generate-config
    runs-on: ubuntu-latest
    outputs:
      addons: ${{ steps.filter.outputs.changes }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üìÇ Run Paths Filter
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: ${{ needs.generate-config.outputs.filters }}

  # --------------------------------------------------------------------------------
  # LINT: Static Analysis (Fail Fast)
  # --------------------------------------------------------------------------------
  lint:
    name: üßπ Lint & Validate
    needs: filter
    if: needs.filter.outputs.addons != '[]' && needs.filter.outputs.addons != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    strategy:
      fail-fast: false
      matrix:
        addon: ${{ fromJSON(needs.filter.outputs.addons) }}
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4

      # 1. ShellCheck
      - name: üêö ShellCheck
        uses: ludeeus/action-shellcheck@2.0.0
        with:
          scandir: "./${{ matrix.addon }}"
        env:
          SHELLCHECK_OPTS: -s bash -e SC2086

      # 2. Hadolint
      - name: üê≥ Hadolint
        uses: brpaz/hadolint-action@v1.5.0
        with:
          dockerfile: "./${{ matrix.addon }}/Dockerfile"

      # 3. Common Linters (Markdown/YAML/JSON/Prettier)
      # We run these once per add-on to ensure focus, or globally if preferred.
      # Running per add-on allows cleaner failure reporting.
      - name: üìù MarkdownLint
        continue-on-error: true
        uses: actionshub/markdownlint@v3.1.4
        with:
          args: "${{ matrix.addon }}/*.md"

      - name: üìÑ YAMLLint
        continue-on-error: true
        uses: frenck/action-yamllint@v1.5
        with:
          args: "./${{ matrix.addon }}/*.yaml"

      - name: üíÖ Prettier
        continue-on-error: true
        run: |
          npm install -g prettier
          prettier --check "${{ matrix.addon }}/**/*.{json,js,md,yaml}" --ignore-path .prettierignore

      # 4. Add-on Linter (Frenck's) - Validates config.yaml/json
      - name: üïµÔ∏è Add-on Linter
        uses: frenck/action-addon-linter@v2
        with:
          path: "./${{ matrix.addon }}"
        continue-on-error: ${{ matrix.addon == 'netboot-xyz' }}

      # 5. Platinum Compliance (S6, Healthcheck, OCI, Translations, Images)
      - name: üì¶ Install Compliance Deps
        run: pip install pyyaml

      - name: üèÜ Platinum Compliance Check
        id: compliance
        continue-on-error: true
        run: |
          set +e
          python3 .scripts/check_compliance.py "./${{ matrix.addon }}" > compliance_report.txt 2>&1
          exit_code=$?
          set -e

          echo "::group::Compliance Report"
          cat compliance_report.txt
          echo "::endgroup::"

          if [ $exit_code -ne 0 ]; then
            echo "status=failure" >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi

      - name: üì§ Upload Compliance Report
        if: steps.compliance.outputs.status == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: compliance-${{ matrix.addon }}
          path: compliance_report.txt
          retention-days: 1

      - name: üõë Fail if Compliance Error
        if: steps.compliance.outputs.status == 'failure'
        run: |
          echo "::error::Compliance checks failed! See 'Platinum Compliance Check' step for details."
          cat compliance_report.txt
          exit 1

      # 6. Security Scan (Trivy)
      # Scanning the directory for vulnerabilities (fs mode)
      # Note: Scanning the built image is better, but this scans deps/conf before build.
      - name: üõ°Ô∏è Trivy Security Scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: "fs"
          scan-ref: "./${{ matrix.addon }}"
          ignore-unfixed: true
          severity: "CRITICAL,HIGH"

  # --------------------------------------------------------------------------------
  # BUILD: Test Build (No Push)
  # --------------------------------------------------------------------------------
  build:
    name: üèóÔ∏è Test Build (${{ matrix.addon }} - ${{ matrix.arch }})
    needs: [filter, lint]
    if: needs.filter.outputs.addons != '[]' && needs.filter.outputs.addons != ''
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        addon: ${{ fromJSON(needs.filter.outputs.addons) }}
        arch: ["aarch64", "amd64"]
    steps:
      - name: ‚§µÔ∏è Check out code
        uses: actions/checkout@v4
  report:
    name: üìä CI & Compliance Report
    needs: [filter, lint, build]
    if: failure() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
      actions: read
    steps:
      - name: üì• Download Compliance Artifacts
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          pattern: compliance-*
          merge-multiple: false
          path: reports

      - name: üìù Post Platinum Compliance Report
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            if (!fs.existsSync('reports')) {
                console.log("No compliance reports found.");
                return;
            }

            const dirs = fs.readdirSync('reports').filter(f => fs.statSync(path.join('reports', f)).isDirectory());
            let summary = "## üõ°Ô∏è Platinum Compliance Issues\n\nThe following add-ons failed compliance checks:\n\n";
            let hasContent = false;
            let totalIssues = 0;
            let missingHealtchecks = 0;
            let missingLogos = 0;

            for (const dir of dirs) {
                const reportPath = path.join('reports', dir, 'compliance_report.txt');
                if (fs.existsSync(reportPath)) {
                   const content = fs.readFileSync(reportPath, 'utf8');
                   const addonName = dir.replace('compliance-', '');

                   if (content.includes("HEALTHCHECK")) missingHealtchecks++;
                   if (content.includes("logo.png")) missingLogos++;
                   totalIssues++;

                   summary += `<details>\n<summary><strong>${addonName}</strong>: ‚ùå Issues Found</summary>\n\n\`\`\`\n${content}\n\`\`\`\n</details>\n\n`;
                   hasContent = true;
                }
            }

            // AI Summary Simulation
            summary += `<details>\n<summary>ü§ñ <strong>AI Summary (Effective Fix Strategy)</strong></summary>\n\n`;
            summary += `> [!TIP]\n> **Quick Fix Analysis**\n>\n`;

            let fixList = "";
            if (missingHealtchecks > 0) fixList += `- broken Healthchecks: Add 'HEALTHCHECK CMD curl --fail http://127.0.0.1:80 || exit 1' to Dockerfile.\n`;
            if (missingLogos > 0) fixList += `- missing Logos: Add 'logo.png' (500x500px) to the add-on root.\n`;

            summary += `\`\`\`text\nFound ${totalIssues} add-on${totalIssues > 1 ? 's' : ''} with issues.\n\n${fixList}\`\`\`\n`;
            summary += `\n</details>\n\n`;

            summary += "\nüíé **Platinum Standards:**\n- Translations (EN/DE)\n- Images (Icon/Logo)\n- Official Base Image\n- S6 Overlay & Healthchecks";

            if (hasContent) {
                // Find existing comments by this bot with signature
                const { data: comments } = await github.rest.issues.listComments({
                   owner: context.repo.owner,
                   repo: context.repo.repo,
                   issue_number: context.issue.number,
                });

                const signature = "## üõ°Ô∏è Platinum Compliance Issues";
                const previousComments = comments.filter(c => c.user.type === 'Bot' && c.body.includes(signature));

                for (const comment of previousComments) {
                    try {
                        await github.graphql(`
                            mutation($subjectId: ID!) {
                                minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                                    minimizedComment {
                                        isMinimized
                                    }
                                }
                            }
                        `, { subjectId: comment.node_id });
                    } catch (error) {
                        console.error(`Failed to minimize comment ${comment.id}:`, error);
                    }
                }

                await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: summary
                });
            }

      - name: üìù Post General CI Failure Report
        uses: actions/github-script@v7
        with:
          script: |
            const { data: jobs } = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.runId,
            });

            const failedJobs = jobs.jobs.filter(j => j.conclusion === 'failure');
            if (failedJobs.length === 0) return;

            // Filter out Compliance-only failures (handled by Platinum Report)
            const nonComplianceJobs = failedJobs.filter(job => {
                const failedStep = job.steps.find(s => s.conclusion === 'failure');
                const stepName = failedStep ? failedStep.name : "";
                return !stepName.includes("Compliance");
            });

            // If all failures are Compliance-related, skip this report (Platinum Report handles it)
            if (nonComplianceJobs.length === 0) {
                console.log("All failures are Compliance-related. Skipping General CI Report.");
                return;
            }

            let report = "## ‚ùå General CI Failure Report\n\nSome checks failed. Here is the diagnostic summary:\n\n";

            // Failed Jobs List (excluding Compliance)
            report += "| Job | Step | Message |\n|---|---|---|\n";
            let affectedAddons = new Set();
            let specificTests = new Set();
            let failureTypes = new Set();

            for (const job of nonComplianceJobs) {
                // Regex to capture "addon" from: "Job Name (addon)" or "Job Name (addon - arch)"
                const match = job.name.match(/\((.*?)(?: -.*)?\)/);
                if (match) affectedAddons.add(match[1]);

                const failedStep = job.steps.find(s => s.conclusion === 'failure');
                const stepName = failedStep ? failedStep.name : "Unknown Step";
                report += `| ${job.name} | ${stepName} | See logs |\n`;

                // Categorize Failure (excluding Compliance)
                if (stepName.includes("Lint") || stepName.includes("Check") || stepName.includes("Prettier")) failureTypes.add("Linting/Static Analysis");
                if (stepName.includes("Build") || job.name.includes("Build")) failureTypes.add("Docker Build");
                if (stepName.includes("Trivy")) failureTypes.add("Security Scan");
                if (stepName.includes("ShellCheck")) failureTypes.add("ShellCheck");
                if (stepName.includes("Hadolint")) failureTypes.add("Hadolint");

                // Map failed step/job to verification script test name
                if (stepName.includes("ShellCheck")) specificTests.add("ShellCheck");
                else if (stepName.includes("Hadolint")) specificTests.add("Hadolint");
                else if (stepName.includes("MarkdownLint")) specificTests.add("MarkdownLint");
                else if (stepName.includes("YAMLLint")) specificTests.add("YamlLint");
                else if (stepName.includes("Prettier")) specificTests.add("Prettier");
                else if (stepName.includes("Add-on Linter")) specificTests.add("AddonLinter");
                else if (stepName.includes("Trivy")) specificTests.add("Trivy");
                else if (job.name.includes("Build")) specificTests.add("DockerBuild");
            }
            report += "\n";

            // AI Summary (as code block for easy copying)
            report += `<details>\n<summary>ü§ñ <strong>AI Summary (Diagnostic)</strong></summary>\n\n`;

            let aiText = "";
            if (affectedAddons.size > 0) {
                 aiText += `Affected Add-ons: ${Array.from(affectedAddons).join(', ')}\n`;
                 aiText += `Failure Categories: ${Array.from(failureTypes).join(', ')}\n`;
                 aiText += `Resolution: Run the local test command below to identify and fix specific errors.`;
            } else {
                 aiText += `Global Workflow Failure: A critical error occurred outside specific add-on checks. Check the workflow logs.`;
            }
            report += `\`\`\`text\n${aiText}\n\`\`\`\n`;
            report += `\n</details>\n\n`;

            // Local Test Command
            report += `<details open>\n<summary>üíª <strong>Local Test Command</strong></summary>\n\n`;
            report += "Run this PowerShell command locally to reproduce and fix issues:\n\n";
            report += "```powershell\n";

            // Construct the tests argument
            let testsArg = "";
            if (specificTests.size > 0) {
                // If only one test, simple string. If multiple, comma separated list in quotes.
                const testsList = Array.from(specificTests).join("', '");
                 testsArg = ` -Tests '${testsList}'`; // Powershell array syntax somewhat, but simple strings work too if parsed right.
                 // Actually powershell param [string[]] accepts comma separated: -Tests "ShellCheck","Hadolint"
                 testsArg = ` -Tests "${Array.from(specificTests).join('","')}"`;
            }

            if (affectedAddons.size > 0) {
                const target = Array.from(affectedAddons)[0]; // Pick first one as example
                report += `.\\.scripts\\verify_addons.ps1 -Addon "${target}" -Fix${testsArg}\n`;
                if (affectedAddons.size > 1) report += "# Repeat for other addons: " + Array.from(affectedAddons).slice(1).join(', ') + "\n";
            } else {
                report += `.\\.scripts\\verify_addons.ps1 -Addon all -Fix${testsArg}\n`;
            }
            report += "```\n";
            report += "\n</details>";

            // Post General Report
            await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: report
            });

  success_report:
    name: ‚úÖ CI Success Summary
    needs: [filter, lint, build]
    if: success() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: write
    steps:
      - name: üìù Post Success Comment
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
               owner: context.repo.owner,
               repo: context.repo.repo,
               issue_number: context.issue.number,
            });

            // Signatures of comments to minimize (cleanup old failures)
            const signatures = [
                "## üõ°Ô∏è Platinum Compliance Issues",
                "## ‚ùå General CI Failure Report"
            ];

            const commentsToMinimize = comments.filter(c =>
                c.user.type === 'Bot' &&
                signatures.some(sig => c.body.includes(sig))
            );

            for (const comment of commentsToMinimize) {
                try {
                    await github.graphql(`
                        mutation($subjectId: ID!) {
                            minimizeComment(input: {subjectId: $subjectId, classifier: OUTDATED}) {
                                minimizedComment {
                                    isMinimized
                                }
                            }
                        }
                    `, { subjectId: comment.node_id });
                } catch (error) {
                    console.error(`Failed to minimize comment ${comment.id}:`, error);
                }
            }

            const body = \`## ‚úÖ Verification Successful

            Thank you for your contribution!

            - üõ°Ô∏è **Platinum Standards**: Compliant
            - üü¢ **CI Checks**: Passed
            - üèóÔ∏è **Build**: Successful

            This PR is likely verifying high quality standards and is ready for review.\`;

            // Check if we already posted a success comment to avoid spamming
            const alreadyPosted = comments.find(c => c.user.type === 'Bot' && c.body.includes("## ‚úÖ Verification Successful"));

            if (!alreadyPosted) {
                await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    body: body
                });
            }

      - name: ‚ÑπÔ∏è Get Add-on Info
        id: info
        uses: home-assistant/actions/helpers/info@master
        with:
          path: "./${{ matrix.addon }}"

      - name: üõë Check Arch Support
        id: check
        run: |
          if [[ "${{ steps.info.outputs.architectures }}" =~ ${{ matrix.arch }} ]]; then
             echo "build_arch=true" >> $GITHUB_OUTPUT
             echo "image=$(echo ${{ steps.info.outputs.image }} | cut -d'/' -f3)" >> $GITHUB_OUTPUT
           else
             echo "Skipping ${{ matrix.arch }} for ${{ matrix.addon }}"
             echo "build_arch=false" >> $GITHUB_OUTPUT
          fi

      - name: üê≥ Build Add-on (Test)
        if: steps.check.outputs.build_arch == 'true'
        uses: home-assistant/builder@2025.11.0
        with:
          args: |
            --test \
            --${{ matrix.arch }} \
            --target /data/${{ matrix.addon }} \
            --image "${{ steps.check.outputs.image }}" \
            --docker-hub "ghcr.io/${{ github.repository_owner }}" \
            --addon
